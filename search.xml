<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>波兰表达式</title>
    <url>/2019/11/18/%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="一：前缀、中缀、后缀表达式【逆波兰表达式】"><a href="#一：前缀、中缀、后缀表达式【逆波兰表达式】" class="headerlink" title="一：前缀、中缀、后缀表达式【逆波兰表达式】"></a>一：前缀、中缀、后缀表达式【逆波兰表达式】</h2><p>1.前缀表达式又称为波兰式，前缀表达式的运算符位于操作数之前</p>
<p>举例说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（3+4）*5-6</span><br></pre></td></tr></table></figure>

<p>对应的前缀表达式就是 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-*+3456</span><br></pre></td></tr></table></figure>

<p>前缀 表达式的计算机求值</p>
<p><img src="/2019/11/18/波兰表达式/D:%5Chexo%5Csource_posts%5C%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%5C1574081408530.png" alt></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>栈解决表达式运算</title>
    <url>/2019/11/18/%E6%A0%88%E8%A7%A3%E5%86%B3%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h2 id="一：问题描述"><a href="#一：问题描述" class="headerlink" title="一：问题描述"></a>一：问题描述</h2><p>使用栈计算：<br>$$<br>7<em>2</em>2-5+1-5+3-4的值，<br>$$<br>模拟计算机的底层操作！</p>
<h2 id="二：思路分析"><a href="#二：思路分析" class="headerlink" title="二：思路分析"></a>二：思路分析</h2><p><img src="/2019/11/18/栈解决表达式运算/1574057233983.png" alt="1574057233983"></p>
<h2 id="三：代码实现"><a href="#三：代码实现" class="headerlink" title="三：代码实现"></a>三：代码实现</h2><p>使用数组设置的栈：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ArrayStack2</span><br><span class="line">    &#123;</span><br><span class="line">        private int maxsize;//声明栈的长度</span><br><span class="line">        private int top = -1;//栈顶</span><br><span class="line">        private int[] stack;</span><br><span class="line">        //构造器</span><br><span class="line">        public ArrayStack2(int maxsize)</span><br><span class="line">        &#123;</span><br><span class="line">            this.maxsize = maxsize;</span><br><span class="line">            stack = new int[maxsize];</span><br><span class="line">        &#125;</span><br><span class="line">        //栈满</span><br><span class="line">        public bool isFull()</span><br><span class="line">        &#123;</span><br><span class="line">            return top == maxsize - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        //栈空</span><br><span class="line">        public bool isEmpty()</span><br><span class="line">        &#123;</span><br><span class="line">            return top == -1;</span><br><span class="line">        &#125;</span><br><span class="line">        //入栈-push</span><br><span class="line">        public void push(int n)</span><br><span class="line">        &#123;</span><br><span class="line">            if (isFull())</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;栈满，无法添加！&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line">            stack[top] = n;</span><br><span class="line">        &#125;</span><br><span class="line">        //出栈-pop</span><br><span class="line">        public int pop()</span><br><span class="line">        &#123;</span><br><span class="line">            if (isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                throw new Exception(&quot;栈空，无法出栈！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            int value = stack[top];</span><br><span class="line">            top--;</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">        //遍历栈</span><br><span class="line">        public void showlist()</span><br><span class="line">        &#123;</span><br><span class="line">            if (isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                throw new Exception(&quot;栈空，无法出栈！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = top; i &gt;= 0; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //返回运算符的优先级，优先级是程序员来确定。</span><br><span class="line">        //优先级使用数字表示，数字越大优先级越高。</span><br><span class="line">        public int priority(int oper)</span><br><span class="line">        &#123;</span><br><span class="line">            if (oper==&apos;*&apos;||oper==&apos;/&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (oper == &apos;+&apos; || oper == &apos;-&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断是不是一个运算符</span><br><span class="line">        public bool isOper(char val)</span><br><span class="line">        &#123;</span><br><span class="line">            return val == &apos;+&apos; || val == &apos;-&apos; || val == &apos;*&apos; || val == &apos;/&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        //计算方法</span><br><span class="line">        public int cal(int num1,int num2,int oper)</span><br><span class="line">        &#123;</span><br><span class="line">            int res = 0;</span><br><span class="line">            switch (oper)</span><br><span class="line">            &#123;</span><br><span class="line">                case &apos;+&apos;:</span><br><span class="line">                    res= num1 + num2;</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;-&apos;:</span><br><span class="line">                    res = num2 - num1;</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;*&apos;:</span><br><span class="line">                    res = num1 * num2;</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;/&apos;:</span><br><span class="line">                    res = num1 / num2;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        //可以返回当前栈顶的值</span><br><span class="line">        public int peek()</span><br><span class="line">        &#123;</span><br><span class="line">            return stack[top];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在Main函数中执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">       #region 计算表达式(只能计算1-9的加、减、乘、除操作！)</span><br><span class="line">          string str = &quot;7+2*6-4*2&quot;;</span><br><span class="line">          char[] vs = str.ToCharArray();</span><br><span class="line">          //声明两个栈，一个存放数字，一个存放符合</span><br><span class="line">          ArrayStack2 numstack = new ArrayStack2(10);</span><br><span class="line">          ArrayStack2 operstack = new ArrayStack2(10);</span><br><span class="line">          int index = 0;</span><br><span class="line">          int num1 = 0;</span><br><span class="line">          int num2 = 0;</span><br><span class="line">          int oper = 0;</span><br><span class="line">          int res = 0;</span><br><span class="line">          char ch = &apos; &apos;;</span><br><span class="line">          while (true)</span><br><span class="line">          &#123;</span><br><span class="line">              //依次得str的每一个字符</span><br><span class="line">              ch = vs[index];</span><br><span class="line">              //判断ch是什么，然后做相应的处理</span><br><span class="line">              if (operstack.isOper(ch))</span><br><span class="line">              &#123;</span><br><span class="line">                  //判断当前的字符栈是否为空</span><br><span class="line">                  if (!operstack.isEmpty())</span><br><span class="line">                  &#123;</span><br><span class="line">                      if (operstack.priority(ch) &lt;= operstack.priority(operstack.peek()))</span><br><span class="line">                      &#123;</span><br><span class="line">                          num1 = numstack.pop();</span><br><span class="line">                          num2 = numstack.pop();</span><br><span class="line">                          oper = operstack.pop();</span><br><span class="line">                          res = numstack.cal(num1, num2, oper);</span><br><span class="line">                          //入栈</span><br><span class="line">                          numstack.push(res);</span><br><span class="line">                          //当前符号入符号栈</span><br><span class="line">                          operstack.push(ch);</span><br><span class="line">                      &#125;</span><br><span class="line">                      else</span><br><span class="line">                      &#123;</span><br><span class="line">                          operstack.push(ch);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  else</span><br><span class="line">                  &#123;</span><br><span class="line">                      //数字入栈</span><br><span class="line">                      operstack.push(ch);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              else</span><br><span class="line">              &#123;</span><br><span class="line">                  numstack.push(ch - 48);</span><br><span class="line">              &#125;</span><br><span class="line">              index++;</span><br><span class="line">              if (index &gt;= vs.Length)</span><br><span class="line">              &#123;</span><br><span class="line">                  break;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          while (true)</span><br><span class="line">          &#123;</span><br><span class="line">              //如果符号栈为空，则计算到最后的结果，数栈就是最终的结果</span><br><span class="line">              if (operstack.isEmpty())</span><br><span class="line">              &#123;</span><br><span class="line">                  break;</span><br><span class="line">              &#125;</span><br><span class="line">              num1 = numstack.pop();</span><br><span class="line">              num2 = numstack.pop();</span><br><span class="line">              oper = operstack.pop();</span><br><span class="line">              res = numstack.cal(num1, num2, oper);</span><br><span class="line">              //入栈</span><br><span class="line">              numstack.push(res);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          Console.WriteLine(&quot;表达式：&#123;0&#125;的结果=&#123;1&#125;&quot;, str, numstack.pop());</span><br><span class="line">          #endregion</span><br><span class="line"></span><br><span class="line">          Console.ReadKey();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h2 id="四：源码地址"><a href="#四：源码地址" class="headerlink" title="四：源码地址"></a>四：源码地址</h2><p><a href="https://github.com/zc282840325/DataStructure/tree/master/数据结构-栈" target="_blank" rel="noopener">Github源码地址</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2019/11/18/%E6%A0%88/</url>
    <content><![CDATA[<h2 id="一：介绍栈"><a href="#一：介绍栈" class="headerlink" title="一：介绍栈"></a>一：介绍栈</h2><ol>
<li>栈的英文（stack）</li>
<li>栈是一个<strong>先入先出（FILO-First In Last Out）</strong>的有序列表。</li>
<li>栈（stack）是限制线性表中元素的插入和删除只能在线性表的同一个端机械能一种特殊线性表。允许插入和删除的一端，为变化的一端，称为<strong>栈顶（TOP)</strong>,另一端为固定的一端，称为<strong>栈底（Bottom）</strong>。</li>
<li>根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除。</li>
</ol>
<p><img src="/2019/11/18/栈/1574047858600.png" alt="1574047858600"></p>
<h2 id="二：栈的引用场景"><a href="#二：栈的引用场景" class="headerlink" title="二：栈的引用场景"></a>二：栈的引用场景</h2><p><img src="/2019/11/18/栈/1574047995815.png" alt="1574047995815"></p>
<h2 id="三-使用数组模拟栈"><a href="#三-使用数组模拟栈" class="headerlink" title="三:使用数组模拟栈"></a>三:使用数组模拟栈</h2><p><img src="/2019/11/18/栈/1574054079167.png" alt="1574054079167"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ArrayStack</span><br><span class="line">  &#123;</span><br><span class="line">      private int maxsize;//声明栈的长度</span><br><span class="line">      private int top = -1;//栈顶</span><br><span class="line">      private int[] stack;</span><br><span class="line">      //构造器</span><br><span class="line">      public ArrayStack(int maxsize)</span><br><span class="line">      &#123;</span><br><span class="line">          this.maxsize = maxsize;</span><br><span class="line">          stack = new int[maxsize];</span><br><span class="line">      &#125;</span><br><span class="line">      //栈满</span><br><span class="line">      public bool isFull()</span><br><span class="line">      &#123;</span><br><span class="line">          return top == maxsize - 1;</span><br><span class="line">      &#125;</span><br><span class="line">      //栈空</span><br><span class="line">      public bool isEmpty()</span><br><span class="line">      &#123;</span><br><span class="line">          return top == -1;</span><br><span class="line">      &#125;</span><br><span class="line">      //入栈-push</span><br><span class="line">      public void push(int n)</span><br><span class="line">      &#123;</span><br><span class="line">          if (isFull())</span><br><span class="line">          &#123;</span><br><span class="line">              Console.WriteLine(&quot;栈满，无法添加！&quot;);</span><br><span class="line">              return;</span><br><span class="line">          &#125;</span><br><span class="line">          top++;</span><br><span class="line">          stack[top] = n;</span><br><span class="line">      &#125;</span><br><span class="line">      //出栈-pop</span><br><span class="line">      public int pop()</span><br><span class="line">      &#123;</span><br><span class="line">          if (isEmpty())</span><br><span class="line">          &#123;</span><br><span class="line">              throw new Exception(&quot;栈空，无法出栈！&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          int value=stack[top];</span><br><span class="line">          top--;</span><br><span class="line">          return value;</span><br><span class="line">      &#125;</span><br><span class="line">      //遍历栈</span><br><span class="line">      public void showlist()</span><br><span class="line">      &#123;</span><br><span class="line">          if (isEmpty())</span><br><span class="line">          &#123;</span><br><span class="line">              throw new Exception(&quot;栈空，无法出栈！&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          for (int i = top; i &gt;= 0; i--)</span><br><span class="line">          &#123;</span><br><span class="line">              Console.WriteLine(pop());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h2 id="四：使用链表模拟栈"><a href="#四：使用链表模拟栈" class="headerlink" title="四：使用链表模拟栈"></a>四：使用链表模拟栈</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LinkedStack</span><br><span class="line">   &#123;</span><br><span class="line">       public Node head = new Node(-1);//虚拟头结点</span><br><span class="line">       //链空</span><br><span class="line">       public bool isEmpty()</span><br><span class="line">       &#123;</span><br><span class="line">           return head.next == null;</span><br><span class="line">       &#125;</span><br><span class="line">       //入栈</span><br><span class="line">       public void push(int n)</span><br><span class="line">       &#123;</span><br><span class="line">           Node temp = new Node(n);</span><br><span class="line">           Node temp2 = head;</span><br><span class="line">               while (temp2.next != null)</span><br><span class="line">               &#123;</span><br><span class="line">                   temp2 = temp2.next;</span><br><span class="line">               &#125;</span><br><span class="line">               temp2.next = temp;</span><br><span class="line">        </span><br><span class="line">       &#125;</span><br><span class="line">       //出栈</span><br><span class="line">       public int pop()</span><br><span class="line">       &#123;</span><br><span class="line">           Node temp =head;</span><br><span class="line">           int value = 0;</span><br><span class="line">           if (temp.next == null)</span><br><span class="line">           &#123;</span><br><span class="line">               temp.next = null;</span><br><span class="line">           &#125;</span><br><span class="line">           else</span><br><span class="line">           &#123;</span><br><span class="line">               value = temp.next.no;</span><br><span class="line">               temp.next = temp.next.next;</span><br><span class="line">           &#125;</span><br><span class="line">           return value;</span><br><span class="line">       &#125;</span><br><span class="line">       //展示列表</span><br><span class="line">       public void showlist()</span><br><span class="line">       &#123;</span><br><span class="line">           Node temp = head;</span><br><span class="line">           if (isEmpty())</span><br><span class="line">           &#123;</span><br><span class="line">               Console.WriteLine(&quot;栈空！&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           while (temp.next!=null)</span><br><span class="line">           &#123;</span><br><span class="line">               Console.WriteLine(pop());</span><br><span class="line">               temp = temp.next;</span><br><span class="line">           &#125;</span><br><span class="line">           Console.WriteLine(temp.no);</span><br><span class="line">       &#125; </span><br><span class="line">   &#125;</span><br><span class="line">   public class Node</span><br><span class="line">   &#123;</span><br><span class="line">       public int no;</span><br><span class="line">       public Node next;</span><br><span class="line">       public Node(int no)</span><br><span class="line">       &#123;</span><br><span class="line">           this.no = no;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>单向环形链表</title>
    <url>/2019/11/17/%E5%8D%95%E5%90%91%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="一：单向环形链表应用场景"><a href="#一：单向环形链表应用场景" class="headerlink" title="一：单向环形链表应用场景"></a>一：单向环形链表应用场景</h2><p><img src="/2019/11/17/单向环形链表/1573998435002.png" alt="1573998435002"></p>
<h2 id="二：分析思路："><a href="#二：分析思路：" class="headerlink" title="二：分析思路："></a>二：分析思路：</h2><p>1.自己分析：</p>
<p>给链表编辑一个add（），一个del()，获取链表长度getlength()，默认从1开始数。</p>
<ol>
<li><p>初始化的时候，通过Add方法读取在数据环中，一次加载，接下来。</p>
</li>
<li><p>做while遍历，当读取到m的时候，首先检查链表的长度，如果长度大于1就移除一个元素，当长度等于1的时候跳出循环</p>
<p>代码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">       /// 删除节点</span><br><span class="line">       /// &lt;/summary&gt;</span><br><span class="line">       /// &lt;param name=&quot;no&quot;&gt;节点的值&lt;/param&gt;</span><br><span class="line">       public void del(int no)</span><br><span class="line">       &#123;</span><br><span class="line">           Hero temp = gethead();</span><br><span class="line">           if (no== temp.no)</span><br><span class="line">           &#123;</span><br><span class="line">               if (head.next==foot)</span><br><span class="line">               &#123;</span><br><span class="line">                   Change();</span><br><span class="line">               &#125;</span><br><span class="line">               else</span><br><span class="line">               &#123;</span><br><span class="line">                   temp = foot;</span><br><span class="line">                   temp.next = temp.next.next;</span><br><span class="line">                   head = temp.next;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           else</span><br><span class="line">           &#123;</span><br><span class="line">               temp = getpre(head, no);</span><br><span class="line">               temp.next = temp.next.next;</span><br><span class="line">               Change();</span><br><span class="line">           &#125;</span><br><span class="line">          </span><br><span class="line">       &#125;</span><br><span class="line">       /// &lt;summary&gt;</span><br><span class="line">       /// 只有2个节点的时候，直接出</span><br><span class="line">       /// &lt;/summary&gt;</span><br><span class="line">       public void Change()</span><br><span class="line">       &#123;</span><br><span class="line">           if (head.next == foot)</span><br><span class="line">           &#123;</span><br><span class="line">               Console.Write(head);</span><br><span class="line">               head = foot;</span><br><span class="line">               head.next = null;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       /// &lt;summary&gt;</span><br><span class="line">       /// 获取待删除节点的上一个节点</span><br><span class="line">       /// &lt;/summary&gt;</span><br><span class="line">       /// &lt;param name=&quot;temp&quot;&gt;头节点的&lt;/param&gt;</span><br><span class="line">       /// &lt;param name=&quot;no&quot;&gt;要删除的节点&lt;/param&gt;</span><br><span class="line">       /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">       public Hero getpre(Hero temp,int no)</span><br><span class="line">       &#123;</span><br><span class="line">           while (true)</span><br><span class="line">           &#123;</span><br><span class="line">               if (temp.next.no == no)</span><br><span class="line">               &#123;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">               temp = temp.next;</span><br><span class="line">           &#125;</span><br><span class="line">           if (temp.next==foot)</span><br><span class="line">           &#123;</span><br><span class="line">               foot = temp;</span><br><span class="line">           &#125;</span><br><span class="line">           return temp;</span><br><span class="line">       &#125;</span><br><span class="line">       /// &lt;summary&gt;</span><br><span class="line">       /// 获取链表的长度</span><br><span class="line">       /// &lt;/summary&gt;</span><br><span class="line">       /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">       public int getlength()</span><br><span class="line">       &#123;</span><br><span class="line">           Hero temp = head;</span><br><span class="line">           int num = 0;</span><br><span class="line">           while (true)</span><br><span class="line">           &#123;</span><br><span class="line">               num++;</span><br><span class="line">               temp = temp.next;</span><br><span class="line">               if (temp.no==head.no)</span><br><span class="line">               &#123;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           return num;</span><br><span class="line">       &#125;</span><br><span class="line">       /// &lt;summary&gt;</span><br><span class="line">       /// 输出打印</span><br><span class="line">       /// &lt;/summary&gt;</span><br><span class="line">       /// &lt;param name=&quot;m&quot;&gt;数m下&lt;/param&gt;</span><br><span class="line">       public void showlink(int m)</span><br><span class="line">       &#123;</span><br><span class="line">           Hero temp = head;</span><br><span class="line">           int num = 0;</span><br><span class="line">           int leng = getlength();//获取链表的长度</span><br><span class="line">           if (head == null)</span><br><span class="line">           &#123;</span><br><span class="line">               Console.WriteLine(&quot;参数输入有误，请重新输入！&quot;);</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">           while (true)</span><br><span class="line">           &#123;</span><br><span class="line">               if (temp.next==null)</span><br><span class="line">               &#123;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">               num++;</span><br><span class="line">               if (num%m==0)</span><br><span class="line">               &#123;</span><br><span class="line">                   Console.WriteLine(temp.no);</span><br><span class="line">                   del(temp.no);</span><br><span class="line">               &#125;</span><br><span class="line">               temp = temp.next;</span><br><span class="line">           &#125;</span><br><span class="line">           Console.WriteLine(temp);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>   2.老师分析：</p>
<p>   <img src="/2019/11/17/单向环形链表/1574042353065.png" alt="1574042353065"></p>
<p>代码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">       /// 老师思路的实现</span><br><span class="line">       /// &lt;/summary&gt;</span><br><span class="line">       /// &lt;param name=&quot;startNo&quot;&gt;开始的编号&lt;/param&gt;</span><br><span class="line">       /// &lt;param name=&quot;countNum&quot;&gt;间隔个数（数几下）&lt;/param&gt;</span><br><span class="line">       /// &lt;param name=&quot;nums&quot;&gt;链表长度&lt;/param&gt;</span><br><span class="line">       public void countBoy(int startNo,int countNum,int nums)</span><br><span class="line">       &#123;</span><br><span class="line">           //先对数据进行校验</span><br><span class="line">           if (head==null||startNo&lt;1||startNo&gt;nums)</span><br><span class="line">           &#123;</span><br><span class="line">               Console.WriteLine(&quot;参数输入有误，请重新输入！&quot;);</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">           //创建辅助指针,小孩出圈</span><br><span class="line">           Hero helper = head;//指向最有一个节点</span><br><span class="line">           while (true)</span><br><span class="line">           &#123;</span><br><span class="line">               if (helper.next==head)</span><br><span class="line">               &#123;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">               helper = helper.next;</span><br><span class="line">           &#125;</span><br><span class="line">           //小孩报数钱，先让head和helper移动k-1次</span><br><span class="line">           for (int i = 0; i &lt; startNo-1; i++)</span><br><span class="line">           &#123;</span><br><span class="line">               head = head.next;</span><br><span class="line">               helper = helper.next;</span><br><span class="line">           &#125;</span><br><span class="line">           //当小孩报数时，让head和helper指针同时的移动m-1次，然后出圈</span><br><span class="line">           //这里是一个循环，循环到只有一个节点的时候</span><br><span class="line">           while (true)</span><br><span class="line">           &#123;</span><br><span class="line">               if (helper==head)</span><br><span class="line">               &#123;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">               //让head和helper指针同时的移动countNum - 1次</span><br><span class="line">               for (int i = 0; i &lt; countNum - 1; i++)</span><br><span class="line">               &#123;</span><br><span class="line">                   head = head.next;</span><br><span class="line">                   helper = helper.next;</span><br><span class="line">               &#125;</span><br><span class="line">               Console.WriteLine(&quot;小孩出圈:&quot;+head.no);</span><br><span class="line">               //将head指向的小孩出圈</span><br><span class="line">               head = head.next;</span><br><span class="line">               helper.next = head;</span><br><span class="line">           &#125;</span><br><span class="line">           Console.WriteLine(&quot;最后一个小孩:&quot;+ head.no);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/17/单向环形链表/1574042483920.png" alt="1574042483920"></p>
<h2 id="三：源码地址"><a href="#三：源码地址" class="headerlink" title="三：源码地址"></a>三：源码地址</h2><p><a href="https://github.com/zc282840325/DataStructure/tree/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E5%90%91%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8" target="_blank" rel="noopener">GitHub源码地址</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>双向链表</title>
    <url>/2019/11/15/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="一：为什么要使用双向链表？"><a href="#一：为什么要使用双向链表？" class="headerlink" title="一：为什么要使用双向链表？"></a>一：为什么要使用双向链表？</h2><ol>
<li>单向链表，查找的方向<strong>只能是一个方向</strong>，二双向链表可以向前或向后查询。</li>
<li>单向链表<strong>不能自我删除</strong>，需要靠辅助节点，而双向链表，则可以自我删除，所以我们单链表删除节点时，总是找到temp,temp是待删除节点的前一个节点。</li>
</ol>
<h2 id="二：分析双向链表的增、删、改、查、遍历的功能！"><a href="#二：分析双向链表的增、删、改、查、遍历的功能！" class="headerlink" title="二：分析双向链表的增、删、改、查、遍历的功能！"></a>二：分析双向链表的增、删、改、查、遍历的功能！</h2><p><img src="/2019/11/15/双向链表/1573980862995.png" alt="1573980862995"></p>
<h2 id="三：代码实现"><a href="#三：代码实现" class="headerlink" title="三：代码实现"></a>三：代码实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">namespace demo4</span><br><span class="line">&#123;</span><br><span class="line">   public class DoubleLinkedList</span><br><span class="line">    &#123;</span><br><span class="line">        //初始化一个头结点，头结点不要动，不存放具体的数据</span><br><span class="line">        private HeroNode head = new HeroNode(0, &quot;&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">        //返回头结点</span><br><span class="line">        public HeroNode gethead()</span><br><span class="line">        &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        //显示链表</span><br><span class="line">        public void showLink()</span><br><span class="line">        &#123;</span><br><span class="line">            if (head.next == null)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;链表为空！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            //因为头结点不能懂，我们需要一个辅助变量来遍历</span><br><span class="line">            HeroNode temp = head.next;</span><br><span class="line">            while (true)</span><br><span class="line">            &#123;</span><br><span class="line">                //找到链表的最后</span><br><span class="line">                if (temp.next == null)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(temp);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                Console.WriteLine(temp);</span><br><span class="line">                //将temp后移</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //添加节点到单向链表</span><br><span class="line">        public void add(HeroNode heroNode)</span><br><span class="line">        &#123;</span><br><span class="line">            //因为head节点不能动，因此我们需要一个辅助遍历temp</span><br><span class="line">            HeroNode temp = head;</span><br><span class="line">            //遍历链表，找到最后</span><br><span class="line">            while (true)</span><br><span class="line">            &#123;</span><br><span class="line">                //找到链表的最后</span><br><span class="line">                if (temp.next == null)</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                //如果没有找到最后</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            //当退出while循环时，temp就指向了链表的最后</span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">            heroNode.pre = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        //按照编号添加</span><br><span class="line">        public void addByOrder(HeroNode heroNode)</span><br><span class="line">        &#123;</span><br><span class="line">            HeroNode temp = head;</span><br><span class="line">            bool flag = false;//标志添加的编号是否存在，默认为false</span><br><span class="line">            while (true)</span><br><span class="line">            &#123;</span><br><span class="line">                if (temp.next == null)//说明temp已经在链表的最后</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (temp.next.no &gt; heroNode.no)//位置找到，就在temp后面插入</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                else if (temp.next.no == heroNode.no)</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = true;//说明编号存在</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            //判断flag的值，如果flag==true,说明编号存在</span><br><span class="line">            if (flag)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;准备插入的英雄的编号&#123;0&#125;已经存在了，不能加入\n&quot;, heroNode.no);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                //插入到temp后面</span><br><span class="line">                temp.next.pre = heroNode;</span><br><span class="line">                heroNode.next = temp.next;</span><br><span class="line"></span><br><span class="line">                temp.next = heroNode;</span><br><span class="line">                heroNode.pre = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //修改结点的信息，根据编号no来修改，即no编号不能改</span><br><span class="line">        public void update(HeroNode newheroNode)</span><br><span class="line">        &#123;</span><br><span class="line">            if (head.next == null)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;链表为空！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                HeroNode temp = head;</span><br><span class="line">                bool flag = false;//是否找到该结点</span><br><span class="line">                while (true)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (temp == null)</span><br><span class="line">                    &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (temp.no == newheroNode.no)</span><br><span class="line">                    &#123;</span><br><span class="line">                        //找到</span><br><span class="line">                        flag = true;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    temp = temp.next;</span><br><span class="line">                &#125;</span><br><span class="line">                if (flag)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.name = newheroNode.name;</span><br><span class="line">                    temp.nickname = newheroNode.nickname;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot;没有找到编号&#123;0&#125;的结点，不能修改\n&quot;, newheroNode.no);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //删除结点</span><br><span class="line">        public void delete(int n)</span><br><span class="line">        &#123;</span><br><span class="line">            if (head.next == null)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;链表为空！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                HeroNode temp = head;</span><br><span class="line">                bool flag = false;//是否找到该结点</span><br><span class="line">                while (true)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (temp == null)</span><br><span class="line">                    &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (temp.no == n)</span><br><span class="line">                    &#123;</span><br><span class="line">                        //找到</span><br><span class="line">                        flag = true;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    temp = temp.next;</span><br><span class="line">                &#125;</span><br><span class="line">                if (flag)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.pre.next = temp.next;</span><br><span class="line">                    if (temp.next!=null)</span><br><span class="line">                    &#123;</span><br><span class="line">                        temp.next.pre = temp.pre;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot;没有找到编号&#123;0&#125;的结点，不能修改\n&quot;, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class HeroNode</span><br><span class="line">    &#123;</span><br><span class="line">        public int no;</span><br><span class="line">        public string name;</span><br><span class="line">        public string nickname;</span><br><span class="line">        public HeroNode next;//指向下一个节点</span><br><span class="line">        public HeroNode pre;//指向下一个节点</span><br><span class="line">        //构造器</span><br><span class="line">        public HeroNode(int no, string name, string nickname)</span><br><span class="line">        &#123;</span><br><span class="line">            this.no = no;</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.nickname = nickname;</span><br><span class="line">        &#125;</span><br><span class="line">        //为了现实方法，我们重新toString</span><br><span class="line">        public override string ToString()</span><br><span class="line">        &#123;</span><br><span class="line">            return &quot;HeroNode[no=&quot; + no + &quot;,name=&quot; + name + &quot;,nickname=&quot; + nickname + &quot;]&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四：代码地址"><a href="#四：代码地址" class="headerlink" title="四：代码地址"></a>四：代码地址</h2><p><a href="https://github.com/zc282840325/DataStructure/tree/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/demo4" target="_blank" rel="noopener">GitHub源码地址</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>单链表面试题</title>
    <url>/2019/11/15/%E5%8D%95%E9%93%BE%E8%A1%A8%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="一：单链表面试题"><a href="#一：单链表面试题" class="headerlink" title="一：单链表面试题"></a>一：单链表面试题</h2><h3 id="1-求单链表中有效节点的个数："><a href="#1-求单链表中有效节点的个数：" class="headerlink" title="1.求单链表中有效节点的个数："></a>1.求单链表中有效节点的个数：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int getLength()</span><br><span class="line">       &#123;</span><br><span class="line">           if (head.next==null)</span><br><span class="line">           &#123;</span><br><span class="line">               return 0;</span><br><span class="line">           &#125;</span><br><span class="line">           int length = 0;</span><br><span class="line">           HeroNode temp = head;</span><br><span class="line">           while (temp.next != null)</span><br><span class="line">           &#123;</span><br><span class="line">               length++;</span><br><span class="line">               temp = temp.next;</span><br><span class="line">           &#125;</span><br><span class="line">           return length;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-查询单链表中倒数第k个节点"><a href="#2-查询单链表中倒数第k个节点" class="headerlink" title="2.查询单链表中倒数第k个节点"></a>2.查询单链表中倒数第k个节点</h3><p>思路分析：</p>
<ol>
<li><p>首先得知道链表的长度：int length = getLength();</p>
</li>
<li><p>计算倒数的个数和长度的差值+1就是求解的节点【为什么要+1，数组是从0开始】</p>
</li>
<li><p>开始遍历，找到第三个节点就行</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void GetBackByOne(int k)</span><br><span class="line">       &#123;</span><br><span class="line">           if (head.next == null)</span><br><span class="line">           &#123;</span><br><span class="line">               Console.WriteLine(&quot;当前链表为空！&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           int length = getLength();</span><br><span class="line">           if (k&gt;length||k&lt;=0)</span><br><span class="line">           &#123;</span><br><span class="line">               Console.WriteLine(&quot;您输入的个数超过了链表长度，无法查询！&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           int num = length - k+1;</span><br><span class="line">           int count = 0;</span><br><span class="line">           HeroNode temp = head;</span><br><span class="line">           for(int i=0;i&lt;num;i++)</span><br><span class="line">           &#123; </span><br><span class="line">             temp=temp.next;</span><br><span class="line">           &#125;</span><br><span class="line">          Console.WriteLine(temp);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-单链表的反转："><a href="#3-单链表的反转：" class="headerlink" title="3.单链表的反转："></a>3.单链表的反转：</h3><h6 id="自己的傻吊思路："><a href="#自己的傻吊思路：" class="headerlink" title="自己的傻吊思路："></a>自己的傻吊思路：</h6><p>将整个链表读取出来，重新创建一个新的链表，重新赋值</p>
<h6 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void fanzhuan()</span><br><span class="line">       &#123;</span><br><span class="line">           if (head.next == null)</span><br><span class="line">           &#123;</span><br><span class="line">               Console.WriteLine(&quot;当前链表为空！&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           HeroNode temp = head;</span><br><span class="line">           List&lt;HeroNode&gt; list = new List&lt;HeroNode&gt;();</span><br><span class="line">           while (temp.next != null)</span><br><span class="line">           &#123;</span><br><span class="line">               if (temp.no!=0)</span><br><span class="line">               &#123;</span><br><span class="line">                   list.Add(temp);</span><br><span class="line">                   temp = temp.next;</span><br><span class="line">               &#125;</span><br><span class="line">               else</span><br><span class="line">               &#123;</span><br><span class="line">                   temp = temp.next;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           list.Add(temp);</span><br><span class="line">           head.next = null;</span><br><span class="line">           for (int i = list.Count-1; i &gt;=0; i--)</span><br><span class="line">           &#123;</span><br><span class="line">               list[i].next = null;</span><br><span class="line">               add(list[i]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h6 id="大佬的思路："><a href="#大佬的思路：" class="headerlink" title="大佬的思路："></a>大佬的思路：</h6><p>1.先定义一个新的节点reverseHead=new HeroNode();</p>
<p>2.从头到尾遍历原来的链表，每遍历一个节点，并放在新的链表的最前端</p>
<p>3.原来的链表的head.next=reverseHead.next</p>
<p><img src="/2019/11/15/单链表面试题/1573829092659.png" alt="1573829092659"></p>
<h6 id="代码如下：-1"><a href="#代码如下：-1" class="headerlink" title="代码如下："></a>代码如下：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void fanzhuan2(HeroNode head)</span><br><span class="line">      &#123;</span><br><span class="line">          if (head.next == null || head.next.next == null)</span><br><span class="line">          &#123;</span><br><span class="line">              return;</span><br><span class="line">          &#125;</span><br><span class="line">          HeroNode cur=head.next;//获取下一个节点</span><br><span class="line">          HeroNode next = null;</span><br><span class="line">          HeroNode reverseHead = new HeroNode(0, &quot;&quot;, &quot;&quot;);//新建一个节点</span><br><span class="line">          while (cur.next != null)</span><br><span class="line">          &#123;</span><br><span class="line">              next = cur.next;//取下一个节点</span><br><span class="line">              change(ref reverseHead,cur);//插入新节点</span><br><span class="line">              if (next == null)</span><br><span class="line">              &#123;</span><br><span class="line">                  break;</span><br><span class="line">              &#125;</span><br><span class="line">              cur = next;//遍历下个节点</span><br><span class="line">          &#125;</span><br><span class="line">          change(ref reverseHead, next);</span><br><span class="line">          //将头节点替换一下大功完成！！！</span><br><span class="line">          head.next = reverseHead.next;</span><br><span class="line">      &#125;</span><br><span class="line">      public void change(ref HeroNode reverseHead,HeroNode cur)</span><br><span class="line">      &#123;</span><br><span class="line">          HeroNode next = null;</span><br><span class="line">          next = reverseHead.next;</span><br><span class="line">          reverseHead.next = cur;</span><br><span class="line">          cur.next = next;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-从尾到头打印单链表"><a href="#4-从尾到头打印单链表" class="headerlink" title="4.从尾到头打印单链表"></a>4.从尾到头打印单链表</h2><p>方式一：借助栈的特性，先进后出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void Print()</span><br><span class="line">       &#123;</span><br><span class="line">           if (head.next == null)</span><br><span class="line">           &#123;</span><br><span class="line">               Console.WriteLine(&quot;当前链表为空！&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           Stack&lt;HeroNode&gt; nodes = new Stack&lt;HeroNode&gt;();</span><br><span class="line">           HeroNode temp = head.next;</span><br><span class="line">           while (temp.next!=null)</span><br><span class="line">           &#123;</span><br><span class="line">               nodes.Push(temp);</span><br><span class="line">               temp = temp.next;</span><br><span class="line">           &#125;</span><br><span class="line">           nodes.Push(temp);</span><br><span class="line"></span><br><span class="line">           int count = nodes.Count;</span><br><span class="line">           for (int i = 0; i &lt; count; i++)</span><br><span class="line">           &#123;</span><br><span class="line">               Console.WriteLine(nodes.Pop());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>方式二：</p>
<p>思路：</p>
<p>逆向打印单链表</p>
<ol>
<li>先将单链表进行反正操作，然后在便利即可；【会破坏原链表的结构，不可取】参考上面3即可</li>
</ol>
<h2 id="5-合并两个有序的单链表，合并之后的链表依然有序"><a href="#5-合并两个有序的单链表，合并之后的链表依然有序" class="headerlink" title="5.合并两个有序的单链表，合并之后的链表依然有序"></a>5.合并两个有序的单链表，合并之后的链表依然有序</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void hebing(SingleLinkedList reverseHead,ref SingleLinkedList reverseHead2)</span><br><span class="line">&#123;</span><br><span class="line">    HeroNode hero = reverseHead.getHead().next;</span><br><span class="line">    reverseHead2.add(hero);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-代码地址："><a href="#6-代码地址：" class="headerlink" title="6.代码地址："></a>6.代码地址：</h2><p><a href="https://github.com/zc282840325/DataStructure/tree/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/demo3" target="_blank" rel="noopener">Github地址</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-链表</title>
    <url>/2019/11/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="一：介绍链表"><a href="#一：介绍链表" class="headerlink" title="一：介绍链表"></a>一：介绍链表</h2><p>链表是有序的列表，单是它在内存中存储如下：</p>
<p><img src="/2019/11/13/数据结构-链表/1573649162803.png" alt="1573649162803"></p>
<ul>
<li>链表是以节点的方式存储。</li>
<li>每个节点包含data 域，next域：指向下一个节点。</li>
<li>发现链表的各个节点不一定是连续存放。</li>
<li>链表分带头节点的链表和没有头结点的链表，根据实际的需求来确定。</li>
</ul>
<h2 id="二：单链表"><a href="#二：单链表" class="headerlink" title="二：单链表"></a>二：单链表</h2><p><img src="/2019/11/13/数据结构-链表/1573649974144.png" alt="1573649974144"></p>
<p>逻辑结构示意图：</p>
<h2 id="三：应用实例"><a href="#三：应用实例" class="headerlink" title="三：应用实例"></a>三：应用实例</h2><p><img src="/2019/11/13/数据结构-链表/1573699922714.png" alt="1573699922714"></p>
<p>使用带head头的单向链表实现—水浒英雄排行榜管理完成对英雄任务的增删改查操作</p>
<ol>
<li>第一种方法在添加英雄时，直接添加到链表的尾部</li>
</ol>
<p>思路分析：</p>
<p><img src="/2019/11/13/数据结构-链表/1573700123856.png" alt="1573700123856"></p>
<ol start="2">
<li>第二种方式的添加英雄时，根据排名将英雄插入指定位置</li>
</ol>
<p>思路分析：</p>
<p><img src="/2019/11/13/数据结构-链表/1573700198225.png" alt="1573700198225"></p>
<ol start="3">
<li><p>修改结点的功能</p>
<p>思路分析：</p>
<p>先找到该结点，通过遍历</p>
<p>通过   temp.name = newheroNode.name; temp.nickname = newheroNode.nickname;</p>
</li>
<li><p>删除结点的功能</p>
<p>思路分析：</p>
<p><img src="/2019/11/13/数据结构-链表/1573700341117.png" alt="1573700341117"></p>
</li>
</ol>
<h2 id="四：代码演示"><a href="#四：代码演示" class="headerlink" title="四：代码演示"></a>四：代码演示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SingleLinkedList</span><br><span class="line">    &#123;</span><br><span class="line">        //初始化一个头结点，头结点不要动，不存放具体的数据</span><br><span class="line">        private HeroNode head = new HeroNode(0,&quot;&quot;,&quot;&quot;);</span><br><span class="line">        //添加节点到单向链表</span><br><span class="line">        //思路，当不考虑编号顺序是</span><br><span class="line">        //1.找到当前链表的最后节点</span><br><span class="line">        //2.将最后这个节点的next指向新的节点</span><br><span class="line">        public void add(HeroNode heroNode)</span><br><span class="line">        &#123;</span><br><span class="line">            //因为head节点不能动，因此我们需要一个辅助遍历temp</span><br><span class="line">            HeroNode temp = head;</span><br><span class="line">            //遍历链表，找到最后</span><br><span class="line">            while (true)</span><br><span class="line">            &#123;</span><br><span class="line">                //找到链表的最后</span><br><span class="line">                if (temp.next==null)</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                //如果没有找到最后</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            //当退出while循环时，temp就指向了链表的最后</span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">        //显示链表</span><br><span class="line">        public void showLink()</span><br><span class="line">        &#123;</span><br><span class="line">            if (head.next==null)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;链表为空！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            //因为头结点不能懂，我们需要一个辅助变量来遍历</span><br><span class="line">            HeroNode temp = head.next;</span><br><span class="line">            while (true)</span><br><span class="line">            &#123;</span><br><span class="line">                //找到链表的最后</span><br><span class="line">                if (temp.next == null)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(temp);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                Console.WriteLine(temp);</span><br><span class="line">                //将temp后移</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //第二种方式在添加英雄的时候，根据排名将英雄插入到指定位置</span><br><span class="line">        //如果有这个排名，则添加失败</span><br><span class="line">        public void addByOrder(HeroNode heroNode)</span><br><span class="line">        &#123;</span><br><span class="line">            HeroNode temp = head;</span><br><span class="line">            bool flag = false;//标志添加的编号是否存在，默认为false</span><br><span class="line">            while (true)</span><br><span class="line">            &#123;</span><br><span class="line">                if (temp.next==null)//说明temp已经在链表的最后</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (temp.next.no&gt;heroNode.no)//位置找到，就在temp后面插入</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line">                   </span><br><span class="line">                &#125;</span><br><span class="line">                else if(temp.next.no==heroNode.no)</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = true;//说明编号存在</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            //判断flag的值，如果flag==true,说明编号存在</span><br><span class="line">            if (flag)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;准备插入的英雄的编号&#123;0&#125;已经存在了，不能加入\n&quot;,heroNode.no);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                //插入到temp后面</span><br><span class="line">                heroNode.next = temp.next;</span><br><span class="line">                temp.next = heroNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //修改结点的信息，根据编号no来修改，即no编号不能改</span><br><span class="line">        public void update(HeroNode newheroNode)</span><br><span class="line">        &#123;</span><br><span class="line">            if (head.next==null)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;链表为空！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                HeroNode temp = head;</span><br><span class="line">                bool flag = false;//是否找到该结点</span><br><span class="line">                while (true)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (temp==null)</span><br><span class="line">                    &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (temp.no==newheroNode.no)</span><br><span class="line">                    &#123;</span><br><span class="line">                        //找到</span><br><span class="line">                        flag = true;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    temp = temp.next;</span><br><span class="line">                &#125;</span><br><span class="line">                if (flag)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.name = newheroNode.name;</span><br><span class="line">                    temp.nickname = newheroNode.nickname;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot;没有找到编号&#123;0&#125;的结点，不能修改\n&quot;,newheroNode.no);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //删除结点</span><br><span class="line">        public void delete(int n)</span><br><span class="line">        &#123;</span><br><span class="line">            if (head.next == null)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;链表为空！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                HeroNode temp = head;</span><br><span class="line">                bool flag = false;//是否找到该结点</span><br><span class="line">                while (true)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (temp == null)</span><br><span class="line">                    &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (temp.no == n-1)</span><br><span class="line">                    &#123;</span><br><span class="line">                        //找到</span><br><span class="line">                        flag = true;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    temp = temp.next;</span><br><span class="line">                &#125;</span><br><span class="line">                if (flag)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp.next = temp.next.next;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot;没有找到编号&#123;0&#125;的结点，不能修改\n&quot;, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //查询</span><br><span class="line">        public void Select(int n)</span><br><span class="line">        &#123;</span><br><span class="line">            if (head.next == null)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;链表为空！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                HeroNode temp = head;</span><br><span class="line">                bool flag = false;//是否找到该结点</span><br><span class="line">                while (true)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (temp == null)</span><br><span class="line">                    &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (temp.no == n)</span><br><span class="line">                    &#123;</span><br><span class="line">                        //找到</span><br><span class="line">                        flag = true;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    temp = temp.next;</span><br><span class="line">                &#125;</span><br><span class="line">                if (flag)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(temp);</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot;没有找到编号&#123;0&#125;的结点，不能修改\n&quot;, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public class HeroNode</span><br><span class="line">    &#123;</span><br><span class="line">        public int no;</span><br><span class="line">        public string name;</span><br><span class="line">        public string nickname;</span><br><span class="line">        public HeroNode next;//指向下一个节点</span><br><span class="line">        //构造器</span><br><span class="line">        public HeroNode(int no, string name, string nickname)</span><br><span class="line">        &#123;</span><br><span class="line">            this.no = no;</span><br><span class="line">            this.name = name;</span><br><span class="line">            this.nickname = nickname;</span><br><span class="line">        &#125;</span><br><span class="line">        //为了现实方法，我们重新toString</span><br><span class="line">        public override string ToString()</span><br><span class="line">        &#123;</span><br><span class="line">            return &quot;HeroNode[no=&quot; + no + &quot;,name=&quot; + name + &quot;,nickname=&quot; + nickname + &quot;]&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="五：源码地址"><a href="#五：源码地址" class="headerlink" title="五：源码地址"></a>五：源码地址</h2><p><a href="https://github.com/zc282840325/DataStructure/tree/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/demo3" target="_blank" rel="noopener">源码地址</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构--队列</title>
    <url>/2019/11/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="一：介绍队列"><a href="#一：介绍队列" class="headerlink" title="一：介绍队列"></a>一：介绍队列</h2><p>队列是一个有序列表，可以用数组或是链表来实现。</p>
<p>遵循<strong>先入先出</strong>的原则。即：现存入队列的数据，要先取出。后存入的要后去除</p>
<p><img src="/2019/11/12/数据结构-队列/1573570155193.png" alt="1573570155193"></p>
<h2 id="二：数组模拟队列"><a href="#二：数组模拟队列" class="headerlink" title="二：数组模拟队列"></a>二：数组模拟队列</h2><ul>
<li>队列本身就是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图，其中maxSize是该队列的最大容量</li>
<li>因为队列的输出、输入是分布从前后端来处理，因此需要两个变量front及rear分别记录队列前后端的下标，front会随着数据输出而改变，而rear则是随着数据输入二改变</li>
<li>rear是队列最后【含】</li>
<li>front是队列最前元素【不含】</li>
</ul>
<p><img src="/2019/11/12/数据结构-队列/1573570155193.png" alt="1573570155193"></p>
<p>当我们将数据存入队列时称为“addQueue”,addQueue的处理需要2个步骤：</p>
<p>将尾指针往后移:rear+1,当front==rear[空]</p>
<p>若尾指针rear小于队列的最大下标maxSize-1,则将数据存入rear所指定的数组元素中，否则无法存入数据。rear==maxSize-1[队列满] </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AarrayQueue</span><br><span class="line">   &#123;</span><br><span class="line">       //使用数组模拟队列</span><br><span class="line">       private int maxSize;//表示数组最大容量</span><br><span class="line">       private int front;//指向队列头</span><br><span class="line">       private int rear;//队列尾</span><br><span class="line">       private int[] arr;//该数组存放数据，模拟队列</span><br><span class="line">       //创建队列的构造器</span><br><span class="line">       public AarrayQueue(int arrMaxSize)</span><br><span class="line">       &#123;</span><br><span class="line">           maxSize = arrMaxSize;</span><br><span class="line">           arr = new int[maxSize];</span><br><span class="line">           front = -1;//指向队列的头部的前一个位置[不包含]</span><br><span class="line">           rear = -1;//指向队列的尾部[包含]</span><br><span class="line">       &#125;</span><br><span class="line">       //判断队列是否满</span><br><span class="line">       public bool isFull()</span><br><span class="line">       &#123;</span><br><span class="line">           return rear == maxSize - 1;</span><br><span class="line">       &#125;</span><br><span class="line">       //判断队列是否为空</span><br><span class="line">       public bool isEmpty()</span><br><span class="line">       &#123;</span><br><span class="line">           return rear == maxSize;</span><br><span class="line">       &#125;</span><br><span class="line">       //添加数据到队列</span><br><span class="line">       public void addQueue(int n)</span><br><span class="line">       &#123;</span><br><span class="line">           if (isFull())</span><br><span class="line">           &#123;</span><br><span class="line">               Console.WriteLine(&quot;队列已经满了！&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           else</span><br><span class="line">           &#123;</span><br><span class="line">               rear++;</span><br><span class="line">               arr[rear] = n;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //获取数据出队列</span><br><span class="line">       public int getQueue()</span><br><span class="line">       &#123;</span><br><span class="line">           if (isEmpty())</span><br><span class="line">           &#123;</span><br><span class="line">               throw new Exception(&quot;队列已经满了&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           else</span><br><span class="line">           &#123;</span><br><span class="line">               return arr[rear--];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //显示队列的所有数据</span><br><span class="line">       public void showQueue()</span><br><span class="line">       &#123;</span><br><span class="line">           if (isEmpty())</span><br><span class="line">           &#123;</span><br><span class="line">               Console.WriteLine(&quot;当前队列是空的，没有数据！&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           for (int i = 0; i &lt; maxSize; i++)</span><br><span class="line">           &#123;</span><br><span class="line">               Console.Write(arr[i]+&quot;\t&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //显示队列的头数据，</span><br><span class="line">       public int headQueue()</span><br><span class="line">       &#123;</span><br><span class="line">           if (isEmpty())</span><br><span class="line">           &#123;</span><br><span class="line">               throw new Exception(&quot;队列是空的&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           else</span><br><span class="line">           &#123;</span><br><span class="line">               return arr[front+1];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //显示队列的尾数据</span><br><span class="line">       public int footQueue()</span><br><span class="line">       &#123;</span><br><span class="line">           if (isEmpty())</span><br><span class="line">           &#123;</span><br><span class="line">               throw new Exception(&quot;队列是空的&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           else</span><br><span class="line">           &#123;</span><br><span class="line">               return arr[rear];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="三：数组模拟环形队列"><a href="#三：数组模拟环形队列" class="headerlink" title="三：数组模拟环形队列"></a>三：数组模拟环形队列</h2><p>思路：</p>
<ul>
<li>front变量的含义做一个调整：front就指向队列的第一个元素，arr[front]就是队列的第一个元素，front初始值=0。</li>
<li>real变量的含义做一个调整：real指向队列的最后一个元素的后一位置，因为希望空出一个空间做为约定，real初始值=0。</li>
<li>当队列满的时候，条件改为 <strong>(real+1)%maxSize==front[满]</strong></li>
<li>当队列为空的条件，<strong>rear==front[空]</strong></li>
<li>队列的有效的数据的个数(real+maxSize-front)%maxSzie</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">namespace demo2</span><br><span class="line">&#123;</span><br><span class="line">   public class CircleArrayQueue</span><br><span class="line">    &#123;</span><br><span class="line">        //使用数组模拟队列</span><br><span class="line">        private int maxSize;//表示数组最大容量</span><br><span class="line">        private int front;//front就指向队列的第一个元素</span><br><span class="line">        private int rear;//real指向队列的最后一个元素的后一位置</span><br><span class="line">        private int[] arr;//该数组存放数据，模拟队列</span><br><span class="line"></span><br><span class="line">        public CircleArrayQueue(int arrMaxSize)</span><br><span class="line">        &#123;</span><br><span class="line">            maxSize = arrMaxSize;</span><br><span class="line">            arr = new int[maxSize];</span><br><span class="line">        &#125;</span><br><span class="line">        //判断队列是否满</span><br><span class="line">        public bool isFull()</span><br><span class="line">        &#123;</span><br><span class="line">            return (rear + 1) % maxSize == front;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断队列是否为空</span><br><span class="line">        public bool isEmpty()</span><br><span class="line">        &#123;</span><br><span class="line">            return rear == front;</span><br><span class="line">        &#125;</span><br><span class="line">        //添加数据到队列</span><br><span class="line">        public void addQueue(int n)</span><br><span class="line">        &#123;</span><br><span class="line">            if (isFull())</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;队列已经满了！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                arr[rear] = n;</span><br><span class="line">                //将readl后移</span><br><span class="line">                rear = (rear + 1) % maxSize;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //获取数据出队列</span><br><span class="line">        public int getQueue()</span><br><span class="line">        &#123;</span><br><span class="line">            if (isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                throw new Exception(&quot;队列已经满了&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                //这里需要分析出front是指向队列的第一个元素</span><br><span class="line">                //1.先把front对应的值保存到一个临时变量</span><br><span class="line">                //2.将front后移,考虑取莫</span><br><span class="line">                //3.将临时保存的变量返回</span><br><span class="line">                int temp = arr[front];</span><br><span class="line">                front = (front + 1) % maxSize;</span><br><span class="line">                return temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //显示队列的所有数据</span><br><span class="line">        public void showQueue()</span><br><span class="line">        &#123;</span><br><span class="line">            if (isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;当前队列是空的，没有数据！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            //思路，从front开始变量，变量多少个元素</span><br><span class="line">            for (int i = front; i &lt; front+ size(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(arr[i%maxSize] + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //求当前数组的有效个数</span><br><span class="line">        public int size()</span><br><span class="line">        &#123;</span><br><span class="line">            return (rear + maxSize - front) % maxSize;</span><br><span class="line">        &#125;</span><br><span class="line">        //显示队列的头数据，</span><br><span class="line">        public int headQueue()</span><br><span class="line">        &#123;</span><br><span class="line">            if (isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                throw new Exception(&quot;队列是空的&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                return arr[front];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //显示队列的尾数据</span><br><span class="line">        public int footQueue()</span><br><span class="line">        &#123;</span><br><span class="line">            if (isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                throw new Exception(&quot;队列是空的&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                return arr[size()-1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四：源码地址"><a href="#四：源码地址" class="headerlink" title="四：源码地址"></a>四：源码地址</h2><p><a href="https://github.com/zc282840325/DataStructure/tree/master/数据结构-队列" target="_blank" rel="noopener">https://github.com/zc282840325/DataStructure/tree/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-稀疏数组</title>
    <url>/2019/11/12/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="一：稀疏数组基本介绍"><a href="#一：稀疏数组基本介绍" class="headerlink" title="一：稀疏数组基本介绍"></a>一：稀疏数组基本介绍</h2><p>答：当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保护该数组</p>
<h2 id="二：稀疏数组的工作原理："><a href="#二：稀疏数组的工作原理：" class="headerlink" title="二：稀疏数组的工作原理："></a>二：稀疏数组的工作原理：</h2><p><img src="/2019/11/12/稀疏数组/1573527796664.png" alt="1573527796664"></p>
<ol>
<li>记录数组一共有<strong>几行几列</strong>，有多少个不同的值</li>
<li>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模</li>
</ol>
<h2 id="三：应用实例"><a href="#三：应用实例" class="headerlink" title="三：应用实例"></a>三：应用实例</h2><p>五子棋游戏：</p>
<p><img src="/2019/11/12/稀疏数组/1573527984103.png" alt="1573527984103"></p>
<p>二维数组转换为稀疏数组：</p>
<table>
<thead>
<tr>
<th></th>
<th>Row</th>
<th>Clo</th>
<th>Val</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>11</td>
<td>11</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>3</td>
<td>2</td>
</tr>
</tbody></table>
<ul>
<li>11行11列，有效数据有2个</li>
<li>1行2列，数值为1</li>
<li>2行3列，数值为2</li>
</ul>
<p><strong>二维数组转换为稀疏数组的思路：</strong></p>
<ol>
<li>遍历原始的二维数组，得到有效数据的个数sum</li>
<li>根据sum就可以创建稀疏数组sparseArr <strong>int{sum+1}{3}</strong></li>
<li>将二维数组的有效数据存入到稀疏数组中</li>
</ol>
<p><strong>稀疏数组转换为二维数组的思路：</strong></p>
<ol>
<li>先读取稀疏数组第一行，根据第一行的数据，创建原始的二维数组</li>
<li>在读取稀疏书中后几行数据，并赋值原始的二维数组</li>
</ol>
<h2 id="四：代码实现"><a href="#四：代码实现" class="headerlink" title="四：代码实现"></a>四：代码实现</h2><p> //先创建一个原始的二维数据11*11,<br>            //0:表示没有棋子，1表示黑子，2表示白子<br>            int[,] chese = new int[11, 11];<br>            chese[1, 2] = 1;<br>            chese[2, 4] = 2;<br>            chese[7, 8] = 2;<br>            chese[4, 9] = 1;</p>
<p>  Console.WriteLine(“原始的二维数组：”);<br>            for (int i = 0; i &lt; Math.Sqrt(chese.Length); i++)<br>            {<br>                for (int j = 0; j &lt; Math.Sqrt(chese.Length); j++)<br>                {<br>                    Console.Write(“\t” + chese[i, j]);<br>                }<br>                Console.WriteLine(“”);<br>            }</p>
<p>//第一步获取有效值的数据</p>
<p>   int sum = 0;<br>            for (int i = 0; i &lt; Math.Sqrt(chese.Length); i++)<br>            {<br>                for (int j = 0; j &lt; Math.Sqrt(chese.Length); j++)<br>                {<br>                    if (chese[i, j] != 0)<br>                    {<br>                        sum++;<br>                    }<br>                }<br>            }</p>
<p>//第二步创建稀疏数组并赋值</p>
<p> //创建稀疏数组<br>            int[,] res = new int[sum + 1, 3];<br>            //给稀疏数组赋值<br>            res[0, 0] = 11;<br>            res[0, 1] = 11;<br>            res[0, 2] = sum;<br>            //遍历二维数组，将非零的值存入稀疏数组<br>            int count = 0;<br>            for (int i = 0; i &lt; Math.Sqrt(chese.Length); i++)<br>            {<br>                for (int j = 0; j &lt; Math.Sqrt(chese.Length); j++)<br>                {<br>                    if (chese[i, j] != 0)<br>                    {<br>                        count++;<br>                        res[count, 0] = i;<br>                        res[count, 1] = j;<br>                        res[count, 2] = chese[i, j];<br>                    }<br>                }<br>            }</p>
<p>   //打印稀疏数组的值</p>
<p>Console.WriteLine(“稀疏数组:”);<br>            for (int i = 0; i &lt; res.Length / 3; i++)<br>            {<br>                for (int j = 0; j &lt; 3; j++)<br>                {<br>                    Console.Write(“\t” + res[i, j]);<br>                }<br>                Console.WriteLine(“”);<br>            }</p>
<p>[]: <a href="https://github.com/zc282840325/DataStructure/tree/master/数据结构-稀疏数组" target="_blank" rel="noopener">https://github.com/zc282840325/DataStructure/tree/master/数据结构-稀疏数组</a>    “Github”</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-第一章</title>
    <url>/2019/11/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="一：数据结构有哪些结构？"><a href="#一：数据结构有哪些结构？" class="headerlink" title="一：数据结构有哪些结构？"></a>一：数据结构有哪些结构？</h2><p>答：线性结构和非线性结构</p>
<h3 id="1-线性结构"><a href="#1-线性结构" class="headerlink" title="1.线性结构:"></a>1.线性结构:</h3><ul>
<li>线性结构作为最常用的数据结构，其特点是数据元素之间存在<strong>一对一</strong>的线性关系</li>
<li>线性结构有两种 不同的存储结构，即<strong>顺序存储结构(数组)</strong>和<strong>链式存储结构(链表)</strong>。顺序存储结构的线性表称为顺序表，顺序表中的存储元素是连续的</li>
<li>链式存储的线性表称为链表，链表中的<strong>存储元素不一定是连续的</strong>，元素节点中存放数据元素以及相邻元素的地址信息</li>
<li>线性结构常见的有：<strong>数组、队列、链表和栈</strong>。</li>
</ul>
<h3 id="2-非线性结构："><a href="#2-非线性结构：" class="headerlink" title="2.非线性结构："></a>2.非线性结构：</h3><p>非线性结构包含：<strong>二维数组、多维数组，广义表、树结构、图结构</strong>。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>三种最常见的问题</title>
    <url>/2019/11/11/%E4%B8%89%E7%A7%8D%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="一：CPU过高的问题"><a href="#一：CPU过高的问题" class="headerlink" title="一：CPU过高的问题"></a>一：CPU过高的问题</h2><h2 id="二：死锁的问题"><a href="#二：死锁的问题" class="headerlink" title="二：死锁的问题"></a>二：死锁的问题</h2><h2 id="三：内存爆满"><a href="#三：内存爆满" class="headerlink" title="三：内存爆满"></a>三：内存爆满</h2>]]></content>
      <categories>
        <category>线程</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>四大并发类</title>
    <url>/2019/11/11/%E5%9B%9B%E5%A4%A7%E5%B9%B6%E5%8F%91%E7%B1%BB/</url>
    <content><![CDATA[<p>一：我们的集合是没有锁机制的</p>
<p>  所以我们目前的集合都是线程不安全的</p>
<p>二：有哪些线程安全的集合</p>
<ol>
<li>ConcurrentQueue<t>==&gt;Queue</t></li>
<li>ConcurrentDictionary&lt;TKey, TValue&gt; ==&gt;Dictionary</li>
<li>ConcurrentStack<t>==&gt;Stack</t></li>
<li>ConcurrentBag<t>==&gt;list Or LinkList</t></li>
</ol>
<p>三：ConcurrentBag </p>
<p>ConcurrentBag 利用线程槽来分摊Bag中数据</p>
<p>ConcurrentBag 的数据放置咋i多个插入线程的槽位汇总。</p>
<p>底层是链表</p>
<pre><code> ConcurrentBag&lt;int&gt; vs = new ConcurrentBag&lt;int&gt;();
        vs.Add(1);
        vs.Add(2);
Console.WriteLine(vs.Count);
    for (int i = 0; i &lt; vs.Count; i++)
    {
        var result = 0;
        vs.TryTake(out result);
        Console.WriteLine(result);
    }</code></pre><p>四：ConcurrentStack</p>
<p>线程安全的Stack是使用链表实现的，同步版本是用数组实现的</p>
<p>线程安全的Stack是使用Interloacked来实现线程安全，没使用内核锁</p>
<pre><code>ConcurrentStack&lt;int&gt; vs = new ConcurrentStack&lt;int&gt;();
      vs.Push(1);
      vs.Push(2);

      Console.WriteLine(vs.Count);
      for (int i = 0; i &lt; vs.Count; i++)
      {
          var result = 0;
          vs.TryPop(out result);
          Console.WriteLine(result);
      }</code></pre><p>五：ConcurrentQueue<t></t></p>
<p>使用单链表实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ConcurrentQueue&lt;int&gt; vs = new ConcurrentQueue&lt;int&gt;();</span><br><span class="line">           vs.Enqueue(1);</span><br><span class="line"></span><br><span class="line">           var result = 0;</span><br><span class="line">           vs.TryDequeue(out result);</span><br><span class="line">           Console.WriteLine(result);</span><br></pre></td></tr></table></figure>

<p>六：ConcurrentDictionary&lt;TKey, TValue&gt;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ConcurrentDictionary&lt;int, int&gt; dic = new ConcurrentDictionary&lt;int, int&gt;();</span><br><span class="line">           dic.TryAdd(1,10);</span><br><span class="line"></span><br><span class="line">           dic.ContainsKey(1);</span><br><span class="line"></span><br><span class="line">           foreach (var item in dic)</span><br><span class="line">           &#123;</span><br><span class="line">               Console.WriteLine(item.Key+item.Value);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>线程</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>混合模式锁</title>
    <url>/2019/11/11/%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h2 id="一：混合锁"><a href="#一：混合锁" class="headerlink" title="一：混合锁"></a>一：混合锁</h2><p>混合锁=用户模式锁+内核模式锁</p>
<p>1.用户模式锁：</p>
<p>Thread.Sleep(1);让线程休眠毫秒</p>
<p>Thread.Sleep(0);让线程放弃当前的时间片，让本溪拿出更高或者同等线程得到时间片运行</p>
<p>Thread.YieId（）：让线程立即放弃当前时间片，让更低级别的线程得到运行，当其他thread时间片用完，本thread再度唤醒。</p>
<p>Yield&lt;Sleep(0)&lt;Sleep(1)</p>
<p>一个时间片等于30ms</p>
<p>2.混合锁有哪些：</p>
<ol>
<li><p>SemaphoreSlim</p>
</li>
<li><p>ManualResetEventSlim</p>
</li>
<li><p>ReaderWriterLockSlim</p>
</li>
<li><p>ReaderWriterLockSlimWrapper</p>
</li>
</ol>
<p>相比较内核模式，效率更高</p>
<p> 1.ManualResetEventSlim：优化点</p>
<ul>
<li><p>构造函数中已经可以不提供默认状态，默认是false，表示合围状态</p>
</li>
<li><p>使用wait代替waitOne（waitHandle提供了一个方法）</p>
</li>
<li><p>支持任务取消</p>
<pre><code>   public static ManualResetEventSlim manual = new ManualResetEventSlim(true);
    static void Main(string[] args)
    {
        CancellationTokenSource source = new CancellationTokenSource();
        while (true)
        {
            Console.WriteLine(&quot;-----------&quot;);
            try
            {
                    manual.Wait(3, source.Token);
                    Console.WriteLine(&quot;Hello Wordl!&quot;);
                    manual.Set();
                    source.Cancel();      }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
            break;
        }
    }
    Console.ReadKey();
}</code></pre><p><img src="/2019/11/11/混合模式锁/1573438077240.png" alt="1573438077240"></p>
</li>
<li><p>wait()中的实现逻辑</p>
<p>waitone（）调用底层的win32函数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[SecurityCritical]</span><br><span class="line">[**MethodImpl**(MethodImplOptions.InternalCall)]</span><br><span class="line">**private** static extern **int** **WaitOneNative**(SafeHandle waitableSafeHandle, **uint** millisecondsTimeout, **bool** hasThreadAffinity, **bool** exitContext);</span><br></pre></td></tr></table></figure>

<p>wait()：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// System.Threading.ManualResetEventSlim</span><br><span class="line">[__DynamicallyInvokable]</span><br><span class="line">public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken)</span><br><span class="line">&#123;</span><br><span class="line">	this.ThrowIfDisposed();</span><br><span class="line">	cancellationToken.ThrowIfCancellationRequested();</span><br><span class="line">	if (millisecondsTimeout &lt; -1)</span><br><span class="line">	&#123;</span><br><span class="line">		throw new ArgumentOutOfRangeException(&quot;millisecondsTimeout&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	if (!this.IsSet)</span><br><span class="line">	&#123;</span><br><span class="line">		if (millisecondsTimeout == 0)</span><br><span class="line">		&#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">		uint startTime = 0u;</span><br><span class="line">		bool flag = false;</span><br><span class="line">		int num = millisecondsTimeout;</span><br><span class="line">		if (millisecondsTimeout != -1)</span><br><span class="line">		&#123;</span><br><span class="line">			startTime = TimeoutHelper.GetTime();</span><br><span class="line">			flag = true;</span><br><span class="line">		&#125;</span><br><span class="line">		int num2 = 10;</span><br><span class="line">		int num3 = 5;</span><br><span class="line">		int num4 = 20;</span><br><span class="line">		int spinCount = this.SpinCount;</span><br><span class="line">		for (int i = 0; i &lt; spinCount; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			if (this.IsSet)</span><br><span class="line">			&#123;</span><br><span class="line">				return true;</span><br><span class="line">			&#125;</span><br><span class="line">			if (i &lt; num2)</span><br><span class="line">			&#123;</span><br><span class="line">				if (i == num2 / 2)</span><br><span class="line">				&#123;</span><br><span class="line">					Thread.Yield();</span><br><span class="line">				&#125;</span><br><span class="line">				else</span><br><span class="line">				&#123;</span><br><span class="line">					Thread.SpinWait(4 &lt;&lt; i);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">				if (i % num4 == 0)</span><br><span class="line">				&#123;</span><br><span class="line">					Thread.Sleep(1);</span><br><span class="line">				&#125;</span><br><span class="line">				else</span><br><span class="line">				&#123;</span><br><span class="line">					if (i % num3 == 0)</span><br><span class="line">					&#123;</span><br><span class="line">						Thread.Sleep(0);</span><br><span class="line">					&#125;</span><br><span class="line">					else</span><br><span class="line">					&#123;</span><br><span class="line">						Thread.Yield();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if (i &gt;= 100 &amp;&amp; i % 10 == 0)</span><br><span class="line">			&#123;</span><br><span class="line">				cancellationToken.ThrowIfCancellationRequested();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		this.EnsureLockObjectCreated();</span><br><span class="line">		using (cancellationToken.InternalRegisterWithoutEC(ManualResetEventSlim.s_cancellationTokenCallback, this))</span><br><span class="line">		&#123;</span><br><span class="line">			object @lock = this.m_lock;</span><br><span class="line">			lock (@lock)</span><br><span class="line">			&#123;</span><br><span class="line">				while (!this.IsSet)</span><br><span class="line">				&#123;</span><br><span class="line">					cancellationToken.ThrowIfCancellationRequested();</span><br><span class="line">					if (flag)</span><br><span class="line">					&#123;</span><br><span class="line">						num = TimeoutHelper.UpdateTimeOut(startTime, millisecondsTimeout);</span><br><span class="line">						if (num &lt;= 0)</span><br><span class="line">						&#123;</span><br><span class="line">							bool result = false;</span><br><span class="line">							return result;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					this.Waiters++;</span><br><span class="line">					if (this.IsSet)</span><br><span class="line">					&#123;</span><br><span class="line">						int waiters = this.Waiters;</span><br><span class="line">						this.Waiters = waiters - 1;</span><br><span class="line">						bool result = true;</span><br><span class="line">						return result;</span><br><span class="line">					&#125;</span><br><span class="line">					try</span><br><span class="line">					&#123;</span><br><span class="line">						if (!Monitor.Wait(this.m_lock, num))</span><br><span class="line">						&#123;</span><br><span class="line">							bool result = false;</span><br><span class="line">							return result;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					finally</span><br><span class="line">					&#123;</span><br><span class="line">						this.Waiters--;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>2.SemaphoreSlim：信号量</p>
<p>Semaphore的WaitOne或者Release方法的调用大约会耗费1微秒的系统时间，而优化后的SemaphoreSlim则需要大致四分之一微秒。</p>
<p>Semaphore就好像一个栅栏，有一定的容量，当里面的线程数量到达设置的最大值时候，就没有线程可以进去。然后，如果一个线程工作完成以后出来了，那下一个线程就可以进去了。Semaphore的WaitOne或Release等操作分别将自动地递减或者递增信号量的当前计数值。当线程试图对计数值已经为0的信号量执行WaitOne操作时，线程将阻塞直到计数值大于0。在构造Semaphore时，最少需要2个参数。信号量的初始容量和最大的容量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static SemaphoreSlim slim = new SemaphoreSlim(2, 10);</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">       for (int i = 0; i &lt; 10; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Task.Run(()=&gt; &#123;</span><br><span class="line">                Run();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        //等待2秒后</span><br><span class="line">        Thread.Sleep(2000);</span><br><span class="line">        slim.Release(10);      Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">    static void Run()</span><br><span class="line">    &#123;</span><br><span class="line">        slim.Wait();</span><br><span class="line">        Thread.Sleep(1000*5);</span><br><span class="line">        Console.WriteLine(&quot;当前t1=&#123;0&#125;正在运行，时间：&#123;1&#125;&quot;,Thread.CurrentThread.ManagedThreadId,DateTime.Now);</span><br><span class="line">        slim.Release();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>3.ReaderWriterLockSlim</p>
<p>用EnterReadLock代替AcquireReaderLock方法，性能比内核版本要高很多。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static ReaderWriterLockSlim lockSlim = new ReaderWriterLockSlim();</span><br><span class="line"> lockSlim.EnterReadLock();</span><br><span class="line">      lockSlim.ExitReadLock();</span><br><span class="line">      lockSlim.EnterWriteLock();</span><br><span class="line">      lockSlim.ExitWriteLock();</span><br></pre></td></tr></table></figure>

<p>混合锁：先在用户模式下内旋，如果超过一定的值，会切换到内核锁。</p>
<p>​               在内旋的情况下，我们会看到大量的Sleep(0),Sleep(1),Yield等语法</p>
]]></content>
      <categories>
        <category>线程</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Lock锁</title>
    <url>/2019/11/09/Lock%E9%94%81/</url>
    <content><![CDATA[<h2 id="一：监视锁"><a href="#一：监视锁" class="headerlink" title="一：监视锁"></a>一：监视锁</h2><p>Monitor:限定线程个数的一把锁</p>
<p>  Monitor.Enter(b);锁住某一个资源</p>
<p>  Monitor.Exit(b);释放某一个资源</p>
<pre><code>static object lockMe = new object();
       static int num = 0;
       static void Main(string[] args)
       {
           for (int i = 0; i &lt; 5; i++)
           {
               Task.Factory.StartNew(()=&gt; {
                   Run();
               });
           }
Console.ReadKey();
   }
   static void Run()
   {
       for (int i = 0; i &lt; 100; i++)
       {
           var b = false;
           try
           {
               Monitor.Enter(lockMe, ref b);
               Console.WriteLine(num++);
           }
           catch (Exception ex)
           {
               Console.WriteLine(ex.Message);
           }
           finally
           {
               if (b)
               {
                   Monitor.Exit(lockMe);
               }
           }
       }
   }</code></pre><p>简化上面的代码：</p>
<pre><code>   static object lockMe = new object();
    static int num = 0;
    static void Main(string[] args)
    {
        for (int i = 0; i &lt; 5; i++)
        {
            Task.Factory.StartNew(()=&gt; {
                Run();
            });
        }Console.ReadKey();
}
static void Run()
{
    for (int i = 0; i &lt; 100; i++)
    {
        lock (lockMe)
        {
            Console.WriteLine(num++);
        }
    }
}</code></pre><h2 id="二：Lock-Monitor的内部机制"><a href="#二：Lock-Monitor的内部机制" class="headerlink" title="二：Lock/Monitor的内部机制"></a>二：Lock/Monitor的内部机制</h2><p>因为众多的锁机制中，唯独只有Monitor有专有的语法糖，所以比较重视！</p>
]]></content>
      <categories>
        <category>线程</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>互斥锁</title>
    <url>/2019/11/09/%E4%BA%92%E6%96%A5%E9%94%81/</url>
    <content><![CDATA[<h2 id="一：ReaderWriteLock"><a href="#一：ReaderWriteLock" class="headerlink" title="一：ReaderWriteLock"></a>一：ReaderWriteLock</h2><p>从读写的角度进行功能分区</p>
<p>Sqllite:库锁</p>
<p>SqlServer:行锁【锁住行】</p>
<p>多个线程可以一起度，只能让一个线程去写。</p>
<p>读写是8/2开</p>
<p>读和写的时间如果时间比较长，都会影响他们。</p>
<pre><code>static ReaderWriterLock reader = new ReaderWriterLock();
    static void Main(string[] args)
    {
        for (int i = 0; i &lt; 5; i++)
        {
            Task.Factory.StartNew(() =&gt; {
                Read();
            });
        }
        Task.Factory.StartNew(() =&gt; {
            Write();
        });
        Console.ReadKey();
    }
/// &lt;summary&gt;
/// 线程读
/// &lt;/summary&gt;
static void Read()
{
    while (true)
    {
        Thread.Sleep(10);
        reader.AcquireReaderLock(int.MaxValue);
        Thread.Sleep(10);
        Console.WriteLine(&quot;当前t={0}进行读取{1}&quot;,Thread.CurrentContext.ContextID,DateTime.Now);
        reader.ReleaseReaderLock();
    }
}

/// &lt;summary&gt;
/// 线程写
/// &lt;/summary&gt;
static void Write()
{
    while (true)
    {
        Thread.Sleep(3000);

        reader.AcquireWriterLock(int.MaxValue);

        Thread.Sleep(3000);

        Console.WriteLine(&quot;当前t={0}进行写入........................................{1}&quot;, Thread.CurrentContext.ContextID,DateTime.Now);

        reader.ReleaseWriterLock();
    }
}</code></pre><p><img src="/2019/11/09/互斥锁/1573311644550.png" alt="1573311644550"></p>
<h2 id="二：CountdownEvent"><a href="#二：CountdownEvent" class="headerlink" title="二：CountdownEvent"></a>二：CountdownEvent</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static CountdownEvent countdown = new CountdownEvent(10);</span><br></pre></td></tr></table></figure>

<p>限制线程书的一个机制。</p>
<pre><code>  static CountdownEvent countdown = new CountdownEvent(10);
 static void Main(string[] args)
 {
     countdown.Reset(10);
for (int i = 0; i &lt; 10; i++)
 {
     Task.Factory.StartNew(()=&gt; {
         LoadOrders();
     });

 }
 countdown.Wait();
 Console.WriteLine(&quot;所有Orders表执行完毕，恭喜！&quot;);
 countdown.Reset(5);

 for (int i = 0; i &lt; 5; i++)
 {
     Task.Factory.StartNew(() =&gt; {
         LoadProducts();
     });
 }
 countdown.Wait();
 Console.WriteLine(&quot;所有Products表执行完毕，恭喜！&quot;);
 countdown.Reset(2);

 for (int i = 0; i &lt; 2; i++)
 {
     Task.Factory.StartNew(() =&gt; {
         LoadUsers();
     });

 }
 countdown.Wait();
 Console.WriteLine(&quot;所有Users表执行完毕，恭喜！&quot;);
 Console.WriteLine(&quot;所有的表执行完毕，恭喜！&quot;);
      Console.ReadKey();
 }
 /// &lt;summary&gt;
 /// 加载Order表
 /// &lt;/summary&gt;
 static void LoadOrders()
 {
     //将当前的countdown减减操作

     Console.WriteLine(&quot;当前Order正在加载中。。。{0}&quot;,Thread.CurrentThread.ManagedThreadId);
     countdown.Signal();
 }
 /// &lt;summary&gt;
 /// 加载Products表
 /// &lt;/summary&gt;
 static void LoadProducts()
 {
     Console.WriteLine(&quot;当前Products正在加载中。。。{0}&quot;, Thread.CurrentThread.ManagedThreadId);
     countdown.Signal();
 }

 /// &lt;summary&gt;
 /// 加载Users表
 /// &lt;/summary&gt;
 static void LoadUsers()
 {
     Console.WriteLine(&quot;当前Users正在加载中。。。{0}&quot;, Thread.CurrentThread.ManagedThreadId);
     countdown.Signal();

 }</code></pre><p><img src="/2019/11/09/互斥锁/1573312641905.png" alt="1573312641905"></p>
]]></content>
      <categories>
        <category>线程</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>内核模式锁机制</title>
    <url>/2019/11/09/%E5%86%85%E6%A0%B8%E6%A8%A1%E5%BC%8F%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="一：锁机制的内核模式"><a href="#一：锁机制的内核模式" class="headerlink" title="一：锁机制的内核模式"></a>一：锁机制的内核模式</h2><p>1.在万不得已的情况下，不要使用内核模式的锁，因为代价太大。我们可以有其他方法代替，例如：混合锁机制，lock</p>
<p>2.事件锁</p>
<p>3.信号量</p>
<p>4.互斥锁</p>
<h2 id="二：事件锁【开关锁，true、false的变量来进行控制】"><a href="#二：事件锁【开关锁，true、false的变量来进行控制】" class="headerlink" title="二：事件锁【开关锁，true、false的变量来进行控制】"></a>二：事件锁【开关锁，true、false的变量来进行控制】</h2><h3 id="1-自动事件锁【AutoResetEvent】"><a href="#1-自动事件锁【AutoResetEvent】" class="headerlink" title="1.自动事件锁【AutoResetEvent】"></a>1.自动事件锁【AutoResetEvent】</h3><p>场景：可以用此所实现多线程环境下某个变量的自增。【true：表示终止状态，false：表示非终止】</p>
<p> private static AutoResetEvent auto = new AutoResetEvent(true);<br>        static void Main(string[] args)<br>        {<br>            while (true)<br>            {<br>                Thread.Sleep(1000);<br>                Console.WriteLine(“开始检票”);<br>                auto.WaitOne();<br>                Thread.Sleep(1000);<br>                Console.WriteLine(“检票ing”);<br>                auto.Set();<br>                Thread.Sleep(1000);<br>                Console.WriteLine(“检票结束”);<br>            }</p>
<p>}</p>
<p><img src="/2019/11/09/内核模式锁机制/1573283569284.png" alt="1573283569284"></p>
<h3 id="2-手动时间锁-ManualResetEvent"><a href="#2-手动时间锁-ManualResetEvent" class="headerlink" title="2.手动时间锁[ManualResetEvent]"></a>2.手动时间锁[ManualResetEvent]</h3><pre><code>private static ManualResetEvent manual = new ManualResetEvent(true);
       manual.WaitOne();
       manual.Set();</code></pre><h3 id="3-注意点：两者ManualResetEvent和AutoResetEvent是不一样的，所以不能混用。"><a href="#3-注意点：两者ManualResetEvent和AutoResetEvent是不一样的，所以不能混用。" class="headerlink" title="3.注意点：两者ManualResetEvent和AutoResetEvent是不一样的，所以不能混用。"></a>3.注意点：两者ManualResetEvent和AutoResetEvent是不一样的，所以不能混用。</h3><h3 id="4-Semaphore-通过int整数来控制线程个数"><a href="#4-Semaphore-通过int整数来控制线程个数" class="headerlink" title="4.Semaphore:[通过int整数来控制线程个数]"></a>4.Semaphore:[通过int整数来控制线程个数]</h3><p>static Semaphore semaphore = new Semaphore(1,1);当前只能是一个线程通过</p>
<h3 id="5-Mutex-互斥锁，同一时间只有一个线程可以拥有它，该类还可用于进程间同步的同步基元。"><a href="#5-Mutex-互斥锁，同一时间只有一个线程可以拥有它，该类还可用于进程间同步的同步基元。" class="headerlink" title="5.Mutex:互斥锁，同一时间只有一个线程可以拥有它，该类还可用于进程间同步的同步基元。"></a>5.Mutex:互斥锁，同一时间只有一个线程可以拥有它，该类还可用于进程间同步的同步基元。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static Mutex mutex = new Mutex();</span><br><span class="line"></span><br><span class="line"> mutex.WaitOne();</span><br><span class="line"></span><br><span class="line"> mutex.ReleaseMutex();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>线程</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>线程锁</title>
    <url>/2019/11/09/%E7%BA%BF%E7%A8%8B%E9%94%81/</url>
    <content><![CDATA[<h2 id="一：锁机制"><a href="#一：锁机制" class="headerlink" title="一：锁机制"></a>一：锁机制</h2><h3 id="1-net锁机制"><a href="#1-net锁机制" class="headerlink" title="1.net锁机制"></a>1.net锁机制</h3><p>时间锁、信号锁、互斥锁、读写锁、互锁，易变构造</p>
<p>分类：</p>
<ol>
<li>用户模式锁：通过一些cpu指令或者一个死循环达到thread等待和休眠。</li>
<li>内核模式锁：调用win32底层的代码，来实现thread的各种操作，如：Thread.Sleep</li>
<li>混合锁：用户模式+内核模式</li>
</ol>
<h3 id="2-为什么要用锁？"><a href="#2-为什么要用锁？" class="headerlink" title="2.为什么要用锁？"></a>2.为什么要用锁？</h3><p>多线程对一个共享资源进行操作的时候，容易出现共享资源混乱的问题</p>
<h2 id="二：用户模式锁"><a href="#二：用户模式锁" class="headerlink" title="二：用户模式锁"></a>二：用户模式锁</h2><ol>
<li><h3 id="易变结构：一个线程读，一个线程写，z在release版本中会有bug"><a href="#易变结构：一个线程读，一个线程写，z在release版本中会有bug" class="headerlink" title="易变结构：一个线程读，一个线程写，z在release版本中会有bug;"></a>易变结构：一个线程读，一个线程写，z在release版本中会有bug;</h3></li>
</ol>
<p>解决问题： </p>
<ul>
<li><p>Thread.MemoryBarrier,  Thread.VolatileRead</p>
</li>
<li><p>关键字：volatile</p>
<ol>
<li><p>不可以底层对代码进行优化</p>
</li>
<li><p>我的Read和Write都是从memrory中读取，读取的数据是最新的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static volatile bool isStop = false;</span><br><span class="line">   static void Main(string[] args)</span><br><span class="line">   &#123;</span><br><span class="line">       var t = new Thread(()=&gt; &#123;</span><br><span class="line">           var isSuccess = false;</span><br><span class="line">           while (!isStop)</span><br><span class="line">           &#123;</span><br><span class="line">               isSuccess = true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       t.Start();</span><br><span class="line">       Thread.Sleep(1000);</span><br><span class="line">       isStop = true;</span><br><span class="line">       t.Join();</span><br><span class="line">       Console.WriteLine(&quot;主线程执行结束！&quot;);</span><br><span class="line">       Console.ReadKey();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h3 id="2-互锁结构：Interlocked-还只能做一些简单类型计算"><a href="#2-互锁结构：Interlocked-还只能做一些简单类型计算" class="headerlink" title="2.互锁结构：Interlocked[还只能做一些简单类型计算]"></a>2.互锁结构：Interlocked[还只能做一些简单类型计算]</h3><p>Interlocked：</p>
<ul>
<li><p>Increment：自增</p>
<pre><code>var sum = 0;
    for (int i = 0; i &lt; 10; i++)
    {
        Interlocked.Increment(ref sum);
    }
     //最后sum=10,自增单位为1</code></pre></li>
<li><p>Decrement：自减</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var sum = 0;</span><br><span class="line">       for (int i = 0; i &lt; 10; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           Interlocked.Decrement(ref sum);</span><br><span class="line">       &#125;</span><br><span class="line">       //最后sum=-10，自减单位为1</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>Exchange：赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var sum = 5;</span><br><span class="line">Interlocked.Exchange(ref sum,10);</span><br><span class="line">//最好sum=10;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Add:增加指定的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var sum = 5;</span><br><span class="line">Interlocked.Add(ref sum,2);</span><br><span class="line">//最好sum=7</span><br></pre></td></tr></table></figure>
</li>
<li><p>CompareExchange：比较赋值</p>
<pre><code>var sum = 5;
Interlocked.CompareExchange(ref sum, 6, 5);
//如果sum==5,true：sum=6,false=5;</code></pre><h3 id="3-旋转锁：Soinlock"><a href="#3-旋转锁：Soinlock" class="headerlink" title="3.旋转锁：Soinlock"></a>3.旋转锁：Soinlock</h3></li>
</ul>
<p>特殊的业务逻辑让thread在用户模式下进行自选，欺骗cpu当前thread正在运行中</p>
<p>用户模式—&gt;内核模式—&gt;用户模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static SpinLock spinLock = new SpinLock();</span><br><span class="line">   static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; 3; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                var task = Task.Factory.StartNew(()=&gt; &#123;</span><br><span class="line">                    Run();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">   static void Run()</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; 100; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                try</span><br><span class="line">                &#123;</span><br><span class="line">                    var b = false;</span><br><span class="line">                    spinLock.Enter(ref b); ;</span><br><span class="line">                    num++;</span><br><span class="line">                    Console.WriteLine(num);</span><br><span class="line">                &#125;</span><br><span class="line">                catch (Exception ex)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(ex.Message);</span><br><span class="line">                &#125;</span><br><span class="line">                finally</span><br><span class="line">                &#123;</span><br><span class="line">                    spinLock.Exit();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/09/线程锁/D:%5Chexo%5Csource_posts%5C%E7%BA%BF%E7%A8%8B%E9%94%81%5C1573279748631.png" alt="1573279748631"></p>
<p>SpinLock 仅当您确定这样做可以改进应用程序的性能之后才能使用。另外，务必请注意 SpinLock 是一个值类型（出于性能原因）。因此，您必须非常小心，不要意外复制了 SpinLock 实例，因为两个实例（原件和副本）之间完全独立，这可能会导致应用程序出现错误行为。如果必须传递 SpinLock 实例，则应该通过引用而不是通过值传递。</p>
<p>不要将 SpinLock 实例存储在只读字段中</p>
<p>当锁是细粒度的并且数量巨大（例如链接的列表中每个节点一个锁）时以及锁保持时间总是非常短时，旋转可能非常有帮助</p>
]]></content>
      <categories>
        <category>线程</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>异步编程awaint</title>
    <url>/2019/11/08/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8Bawaint/</url>
    <content><![CDATA[<h2 id="一：async-await"><a href="#一：async-await" class="headerlink" title="一：async await"></a>一：async await</h2><ul>
<li>调用方法：该方法调用异步方法，然后在异步方法执行其任务的时候继续执行；</li>
<li>异步方法：该方法异步执行工作，然后立刻返回到调用方法；</li>
<li>await 表达式：用于异步方法内部，指出需要异步执行的任务。一个异步方法可以包含多个 await 表达式（不存在 await 表达式的话 IDE 会发出警告）。</li>
</ul>
<h2 id="二、async-await-结构"><a href="#二、async-await-结构" class="headerlink" title="二、async/await 结构"></a>二、async/await 结构</h2><ul>
<li><p>同步方法：一个程序调用某个方法，等到其执行完成之后才进行下一步操作。这也是默认的形式。</p>
</li>
<li><p>异步方法：一个程序调用某个方法，在处理完成之前就返回该方法。通过 async/await 我们就可以实现这种类型的方法。</p>
</li>
</ul>
<h2 id="三：-异步方法"><a href="#三：-异步方法" class="headerlink" title="三： 异步方法"></a>三： 异步方法</h2><ul>
<li>关键字：方法头使用 async 修饰。</li>
<li>要求：包含 N（N&gt;0） 个 await 表达式（不存在 await 表达式的话 IDE 会发出警告），表示需要异步执行的任务。</li>
<li>​     （3）返回类型：只能返回 3 种类型（void、Task 和 Task<t>）。Task 和 Task<t> 标识返回的对象会在将来完成工作，表示调用方法和异步方法可以继续执行。</t></t></li>
<li>参数：数量不限，但不能使用 out 和 ref 关键字。</li>
<li>命名约定：方法后缀名应以 Async 结尾。</li>
<li>其它：匿名方法和 Lambda 表达式也可以作为异步对象；async 是一个上下文关键字；关键字 async 必须在返回类型前。</li>
</ul>
<p><img src="/2019/11/08/异步编程awaint/1573227579628.png" alt="1573227579628"></p>
]]></content>
      <categories>
        <category>线程</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Task多线程模型</title>
    <url>/2019/11/08/Task%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="一：同步编程模型-SPM"><a href="#一：同步编程模型-SPM" class="headerlink" title="一：同步编程模型(SPM)"></a>一：同步编程模型(SPM)</h2><p>单线线程、串行开发模式。</p>
<h2 id="二：异步编程模型（APM）"><a href="#二：异步编程模型（APM）" class="headerlink" title="二：异步编程模型（APM）"></a>二：异步编程模型（APM）</h2><p>xxxbegin、xxxend的模式。</p>
<pre><code>   FileStream file = new FileStream(Environment.CurrentDirectory+&quot;//1.txt&quot;,FileMode.Open);
var bytes= new byte[file.Length];

   file.BeginRead(bytes,0,bytes.Length,(ary)=&gt; {
       var nums = file.EndRead(ary);
       Console.WriteLine(nums);
   },string.Empty);

   Console.Read();</code></pre><h2 id="三：基于事件的编程模型（EAP）"><a href="#三：基于事件的编程模型（EAP）" class="headerlink" title="三：基于事件的编程模型（EAP）"></a>三：基于事件的编程模型（EAP）</h2><p>xxAsync这样的事件模式。 eg：WebClient。</p>
<h2 id="四：基于Task的编程模型（TAP）"><a href="#四：基于Task的编程模型（TAP）" class="headerlink" title="四：基于Task的编程模型（TAP）"></a>四：基于Task的编程模型（TAP）</h2><p> APM和EAP都可以使用Task来实现，微软的初衷就是想通过Task大一统异步编程领域</p>
<p>使用Task封装APM模式：</p>
<p>代码量小</p>
<p>Task更简单</p>
<pre><code>FileStream file = new FileStream(Environment.CurrentDirectory+&quot;//1.txt&quot;,FileMode.Open);

       var bytes= new byte[file.Length];
        var task = Task.Factory.FromAsync(file.BeginRead, file.EndRead, bytes, 0, bytes.Length, string.Empty);

        var nums = task.Result;
        Console.WriteLine(nums);</code></pre><p>使用Task包装EAP</p>
<p>TaskCompletionSource：包装器</p>
<pre><code>  private static Task&lt;int&gt; GetTask(string url)
     {
         TaskCompletionSource&lt;int&gt; source = new TaskCompletionSource&lt;int&gt;();
WebClient client = new WebClient();
     client.DownloadDataCompleted += (sendr, e) =&gt;
     {
         try
         {
             source.TrySetResult(e.Result.Length);
         }
         catch (Exception ex)
         {
             source.TrySetException(ex);
         }

     };
     client.DownloadDataAsync(new Uri(url));
     return source.Task;
 }</code></pre>]]></content>
      <categories>
        <category>线程</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Task核心调度器[TaskScheduler]</title>
    <url>/2019/11/08/Task%E6%A0%B8%E5%BF%83%E8%B0%83%E5%BA%A6%E5%99%A8-TaskScheduler/</url>
    <content><![CDATA[<h2 id="一：TaskScheduler"><a href="#一：TaskScheduler" class="headerlink" title="一：TaskScheduler"></a>一：TaskScheduler</h2><p>问：TaskScheduler是做什么的？</p>
<p>答：我们发现任务执行要经过Scheduler。Task的核心就是这个Scheduler，因为他把要执行任务安排在线程或者线程池中。TaskScheduler由Thread和ThreadPool组成。</p>
<p><img src="/2019/11/08/Task核心调度器-TaskScheduler/D:%5Chexo%5Csource_posts%5CTask%E6%A0%B8%E5%BF%83%E8%B0%83%E5%BA%A6%E5%99%A8-TaskScheduler%5C1573211558433.png" alt="1573211558433"></p>
<h2 id="二：在-net-FrameWork中有两种TaskScheduler"><a href="#二：在-net-FrameWork中有两种TaskScheduler" class="headerlink" title="二：在.net FrameWork中有两种TaskScheduler"></a>二：在.net FrameWork中有两种TaskScheduler</h2><h3 id="1-ThreadPoolTaskScheduler"><a href="#1-ThreadPoolTaskScheduler" class="headerlink" title="1.ThreadPoolTaskScheduler"></a>1.ThreadPoolTaskScheduler</h3><p>也就是Task的默认是调用ThreadPool</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected internal override void QueueTask(Task task)</span><br><span class="line">		&#123;</span><br><span class="line">			if ((task.Options &amp; TaskCreationOptions.LongRunning) != TaskCreationOptions.None)</span><br><span class="line">			&#123;</span><br><span class="line">				new Thread(ThreadPoolTaskScheduler.s_longRunningThreadWork)</span><br><span class="line">				&#123;</span><br><span class="line">					IsBackground = true</span><br><span class="line">				&#125;.Start(task);</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			bool forceGlobal = (task.Options &amp; TaskCreationOptions.PreferFairness) &gt; TaskCreationOptions.None;</span><br><span class="line">			ThreadPool.UnsafeQueueCustomWorkItem(task, forceGlobal);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-SynchronizationContextTaskScheduler"><a href="#2-SynchronizationContextTaskScheduler" class="headerlink" title="2.SynchronizationContextTaskScheduler"></a>2.SynchronizationContextTaskScheduler</h3><h4 id="1-同步上下文"><a href="#1-同步上下文" class="headerlink" title="1.同步上下文"></a>1.同步上下文</h4><pre><code>Task task = new Task(() =&gt;
{
    try
    {
        label1.Text = &quot;das&quot;;
    }
    catch (Exception ex)
    {
        MessageBox.Show(ex.Message);
    }
});
task.Start(TaskScheduler.FromCurrentSynchronizationContext());</code></pre><h4 id="2-操作耗时线程"><a href="#2-操作耗时线程" class="headerlink" title="2.操作耗时线程"></a>2.操作耗时线程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var task = Task.Factory.StartNew(() =&gt;</span><br><span class="line">           &#123;</span><br><span class="line">               Thread.Sleep(10000);</span><br><span class="line">           &#125;);</span><br><span class="line">           task.ContinueWith(t =&gt;</span><br><span class="line">           &#123;</span><br><span class="line">               label1.Text = &quot;你好!&quot;;</span><br><span class="line">           &#125;, TaskScheduler.FromCurrentSynchronizationContext());</span><br></pre></td></tr></table></figure>

<p>ContinueWith等待执行完耗时线程，在同步上下文</p>
<h2 id="三：如何自定义Scheduler？"><a href="#三：如何自定义Scheduler？" class="headerlink" title="三：如何自定义Scheduler？"></a>三：如何自定义Scheduler？</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class PerThreadTaskScheduler : TaskScheduler</span><br><span class="line">   &#123;</span><br><span class="line">       /// &lt;summary&gt;</span><br><span class="line">       /// 给debug</span><br><span class="line">       /// &lt;/summary&gt;</span><br><span class="line">       /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">       protected override IEnumerable&lt;Task&gt; GetScheduledTasks()</span><br><span class="line">       &#123;</span><br><span class="line">           return Enumerable.Empty&lt;Task&gt;();</span><br><span class="line">       &#125;</span><br><span class="line">       /// &lt;summary&gt;</span><br><span class="line">       /// 执行Task</span><br><span class="line">       /// &lt;/summary&gt;</span><br><span class="line">       /// &lt;param name=&quot;task&quot;&gt;&lt;/param&gt;</span><br><span class="line">       protected override void QueueTask(Task task)</span><br><span class="line">       &#123;</span><br><span class="line">           var thread = new Thread(()=&gt; &#123;</span><br><span class="line">               TryExecuteTask(task);</span><br><span class="line">           &#125;);</span><br><span class="line">           thread.Start();</span><br><span class="line">       &#125;</span><br><span class="line">       /// &lt;summary&gt;</span><br><span class="line">       /// 同步执行</span><br><span class="line">       /// &lt;/summary&gt;</span><br><span class="line">       /// &lt;param name=&quot;task&quot;&gt;&lt;/param&gt;</span><br><span class="line">       /// &lt;param name=&quot;taskWasPreviouslyQueued&quot;&gt;&lt;/param&gt;</span><br><span class="line">       /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">       protected override bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued)</span><br><span class="line">       &#123;</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>线程</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Task中的Plinq</title>
    <url>/2019/11/06/Task%E4%B8%AD%E7%9A%84Plinq/</url>
    <content><![CDATA[<h2 id="一：Plinq"><a href="#一：Plinq" class="headerlink" title="一：Plinq"></a>一：Plinq</h2><p>问：为什么要使用Plinq？</p>
<p>答：为了能够达到最大的灵活度，Linq又了并行的版本</p>
<h2 id="二：如何把Linq转换为lingq"><a href="#二：如何把Linq转换为lingq" class="headerlink" title="二：如何把Linq转换为lingq"></a>二：如何把Linq转换为lingq</h2><p>1.AsParallel():将串行转换为并行</p>
<pre><code>var nums = Enumerable.Range(0, 100).ToList();
            var query = from n in nums.AsParallel()
                        select new
                        {
                            thread = Thread.CurrentThread.ManagedThreadId,
                            nums = n
                        };

        foreach (var item in query)
        {
            Console.WriteLine(item);
        }</code></pre><p><img src="/2019/11/06/Task中的Plinq/1573051666110.png" alt="1573051666110"></p>
<p>2.AsOrdered()</p>
<p>说明：就是将并行结果还是按照未排序的样式排序</p>
<pre><code>var nums = Enumerable.Range(0, 100).ToList();
            nums[0] = 1000;
                var query = from n in nums.AsParallel().AsOrdered()
                            select new
                            {
                                thread = Thread.CurrentThread.ManagedThreadId,
                                nums = n
                            };
foreach (var item in query)
        {
            Console.WriteLine(item);
        }</code></pre><p><img src="/2019/11/06/Task中的Plinq/1573051832978.png" alt="1573051832978"></p>
<p>可以看出，AsOrdered()是按照1-100的排序输出，如果在前面加1000，还是会输出，并不会对结果在排序。</p>
<p>3.AsUnordered就是AsOrdered的相反的意思</p>
<p>4.AsSequential  《==》AsParallel</p>
<p>前者将plinq转换为linq</p>
<p>后者将Linq转换为Plinq</p>
<pre><code>var nums = Enumerable.Range(0, 100).ToList();
    nums[0] = 1000;
        var query = from n in nums.AsParallel().AsSequential()
                    select new
                    {
                        thread = Thread.CurrentThread.ManagedThreadId,
                        nums = n
                    };
foreach (var item in query)
{
    Console.WriteLine(item);
}</code></pre><p><img src="/2019/11/06/Task中的Plinq/1573052174566.png" alt="1573052174566"></p>
<p>线程串行，<strong>只有一个线程</strong>！</p>
<p>5.plinq底层都是用task的，基6于task的一些编程模型，让我们快速进行计算的。</p>
<pre><code> var nums = Enumerable.Range(0, 100).ToList();
            nums[0] = 1000;
                var query = from n in nums.AsParallel()
                            select new
                            {
                                thread = GetThreadID(),
                                nums = n
                            };
foreach (var item in query)
        {
            Console.WriteLine(item);
        }
        static int GetThreadID()
        {
            Thread.Sleep(1000);
            return Thread.CurrentThread.ManagedThreadId;
        }</code></pre><p><img src="/2019/11/06/Task中的Plinq/1573053268353.png" alt="1573053268353"></p>
<p>6.WithDegreeOfParallelism(Environment.ProcessorCount-1)</p>
<p>设置Task开启线程的数量</p>
<p>7.WithCancellation(source.Token)</p>
<pre><code> CancellationTokenSource source = new CancellationTokenSource();
    source.Cancel();
     var nums = Enumerable.Range(0, 100).ToList();
    nums[0] = 1000;
    var query = from n in nums.AsParallel().WithDegreeOfParallelism(Environment.ProcessorCount - 1)
                .WithCancellation(source.Token)
                    select new
                    {
                        thread = GetThreadID(),
                        nums = n
                    };
foreach (var item in query)
{
    Console.WriteLine(item);
}</code></pre><p><img src="/2019/11/06/Task中的Plinq/1573053600952.png" alt="1573053600952"></p>
<p>如果执行之前被取消，那就不要执行，会以异常保存。</p>
<p>7.WithExecutionMode：此参数可以告诉系统当前是否强制并行</p>
<pre><code>var query = from n in nums.AsParallel().WithDegreeOfParallelism(Environment.ProcessorCount - 1)
                  .WithCancellation(source.Token)
                  .WithExecutionMode(ParallelExecutionMode.ForceParallelism)
                        select new
                      {
                          thread = GetThreadID(),
                          nums = n
                      };</code></pre><p><img src="/2019/11/06/Task中的Plinq/1573053728533.png" alt="1573053728533"></p>
<p>8.WithMergeOptions:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var query = from n in nums.AsParallel().WithDegreeOfParallelism(Environment.ProcessorCount - 1)</span><br><span class="line">                        .WithCancellation(source.Token)</span><br><span class="line">                        .WithExecutionMode(ParallelExecutionMode.ForceParallelism)</span><br><span class="line">                        .WithMergeOptions(ParallelMergeOptions.Default)</span><br><span class="line">                              select new</span><br><span class="line">                            &#123;</span><br><span class="line">                                thread = GetThreadID(),</span><br><span class="line">                                nums = n</span><br><span class="line">                            &#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/06/Task中的Plinq/1573055734213.png" alt="1573055734213"></p>
<p>聚合计算合并</p>
]]></content>
      <categories>
        <category>线程</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Task并行封装</title>
    <url>/2019/11/05/Task%E5%B9%B6%E8%A1%8C%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<h2 id="一：Task中并行和串行"><a href="#一：Task中并行和串行" class="headerlink" title="一：Task中并行和串行"></a>一：Task中并行和串行</h2><p>串行：</p>
<pre><code>for (int i = 0; i &lt; 100; i++)
{
    Console.WriteLine(i);
}</code></pre><p><img src="/2019/11/05/Task并行封装/1572968795179.png" alt="1572968795179"></p>
<p>并行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Parallel.For(0, 100, (item) =&gt;</span><br><span class="line">   &#123;</span><br><span class="line">       Console.WriteLine(item);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/05/Task并行封装/1572968878768.png" alt="1572968878768"></p>
<h2 id="二：Parallel-For的实现结构"><a href="#二：Parallel-For的实现结构" class="headerlink" title="二：Parallel.For的实现结构"></a>二：Parallel.For的实现结构</h2><p>1.可以设置指定的线程计算，不需要所有的线程参与计算。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int nNumExpectedWorkers = (parallelOptions.EffectiveMaxConcurrencyLevel == -1) ? PlatformHelper.ProcessorCount : parallelOptions.EffectiveMaxConcurrencyLevel;</span><br></pre></td></tr></table></figure>

<p>2.分区函数，实现线程并行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RangeManager rangeManager = new RangeManager((long)fromInclusive,(long)toExclusive, 1L, nNumExpectedWorkers);</span><br></pre></td></tr></table></figure>

<p>分区后，使用    ParallelForReplicatingTask处理线程，这个类继承Task</p>
<p>3.不要在Parallel.For中使用break()或Stop()，或许会给你引入不必要的bug；</p>
<pre><code>ConcurrentStack&lt;int&gt; stack = new ConcurrentStack&lt;int&gt;();
      Parallel.For(0, 100, (item,loop) =&gt;
      {
          Thread.Sleep(100000);
          stack.Push(item);
      });
      Console.WriteLine(string.Join(&quot;,&quot;, stack));</code></pre><p><img src="/2019/11/05/Task并行封装/D:%5Chexo%5Csource_posts%5CTask%E5%B9%B6%E8%A1%8C%E5%B0%81%E8%A3%85%5C1573015947294.png" alt="1573015947294"></p>
<p>线程池中开启16个线程，使用了12个线程,还有4个线程是CLR为发生饱和，做备用线程</p>
<h2 id="三-Parallel-For高级重载"><a href="#三-Parallel-For高级重载" class="headerlink" title="三.Parallel.For高级重载"></a>三.Parallel.For高级重载</h2><p>Parallel.For解决问题是数组的遍历。</p>
<p>public static ParallelLoopResult For<tlocal>(<strong>int</strong> fromInclusive, <strong>int</strong> toExclusive, Func<tlocal> localInit, Func&lt;<strong>int</strong>, ParallelLoopState, TLocal, TLocal&gt; body, Action<tlocal> localFinally)</tlocal></tlocal></tlocal></p>
<p>计算1-100的总和</p>
<pre><code>var totalNums = 0;
       Parallel.For(1,100,()=&gt; {
           return 0;
       },(current,loop,total)=&gt; {
           total += (int)current;
           return total;
       },(total)=&gt; {
           Interlocked.Add(ref totalNums,total);
       });
       Console.WriteLine(totalNums);</code></pre><p>结果4950</p>
<h2 id="四：Parallel-Foreach"><a href="#四：Parallel-Foreach" class="headerlink" title="四：Parallel.Foreach()"></a>四：Parallel.Foreach()</h2><p>Parallel.Foreach()应对一些集合运算【非数组】</p>
<pre><code>Dictionary&lt;int, int&gt; dic = new Dictionary&lt;int, int&gt;() { 
{ 1, 100 }, { 2, 200 }, { 3, 300 } };
       Parallel.ForEach(dic,(item)=&gt; {
            Console.WriteLine(item.Key+&quot;:&quot;+item.Value);
        });</code></pre><p><img src="/2019/11/05/Task并行封装/1573048308181.png" alt="1573048308181"></p>
<p><img src="/2019/11/05/Task并行封装/1573048681375.png" alt="1573048681375"></p>
<p>上面是源码，分区函数，首先得分区。</p>
<h2 id="五：Parallel-Invoke（）"><a href="#五：Parallel-Invoke（）" class="headerlink" title="五：Parallel.Invoke（）"></a>五：Parallel.Invoke（）</h2><pre><code>Parallel.Invoke(() =&gt;
{
    Console.WriteLine(&quot;我是并行计算{0}&quot;,Thread.CurrentThread.ManagedThreadId);
}, () =&gt;
{
    Console.WriteLine(&quot;我是并行计算{0}&quot;, Thread.CurrentThread.ManagedThreadId);
}, () =&gt;
{
    Console.WriteLine(&quot;我是并行计算{0}&quot;, Thread.CurrentThread.ManagedThreadId);
});</code></pre><p><img src="/2019/11/05/Task并行封装/1573049137151.png" alt="1573049137151"></p>
<p>Parallel.Invoke()可以同时开始多个线程并行执行，CPU回分配不同的线程执行任务。</p>
]]></content>
      <categories>
        <category>线程</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Task返回值</title>
    <url>/2019/11/05/Task%E8%BF%94%E5%9B%9E%E5%80%BC/</url>
    <content><![CDATA[<h2 id="一：Task的返回值："><a href="#一：Task的返回值：" class="headerlink" title="一：Task的返回值："></a>一：Task的返回值：</h2><p>1.使用Task.Result</p>
<pre><code>Task&lt;int&gt; task = Task.Factory.StartNew(()=&gt; {
    int s = 0;
    for (int i = 0; i &lt; 5; i++)
    {
        s += i;
    }
    return s;
});
Console.WriteLine(task.Result);</code></pre><p><img src="/2019/11/05/Task返回值/1572941896412.png" alt="1572941896412"></p>
<h2 id="二：ContinueWith的返回值"><a href="#二：ContinueWith的返回值" class="headerlink" title="二：ContinueWith的返回值"></a>二：ContinueWith<t>的返回值</t></h2><pre><code>  Task&lt;int&gt; task = Task.Factory.StartNew(()=&gt; {
        int s = 0;
        for (int i = 0; i &lt; 5; i++)
        {
            s += i;
        }
        return s;
    });
    var task2 = task.ContinueWith&lt;string&gt;(t =&gt;
    {var num = t.Result;
    var sum = num + 10;
    return sum.ToString();
});
Console.WriteLine(task2.Result);
Console.ReadKey();</code></pre><p><img src="/2019/11/05/Task返回值/1572942000959.png" alt="1572942000959"></p>
<h2 id="三：Task-WhenAll-WhenAny"><a href="#三：Task-WhenAll-WhenAny" class="headerlink" title="三：Task.WhenAll/WhenAny"></a>三：Task.WhenAll<t>/WhenAny</t></h2><pre><code>   Task&lt;int&gt; task = Task.Factory.StartNew(() =&gt;
      {
          return 6;
      });
Task&lt;int&gt; task2 = Task.Factory.StartNew(() =&gt;
  {
      return 2;
  });
  int[] result = Task.WhenAll&lt;int&gt;(new Task&lt;int&gt;[2] { task, task2 }).Result;

  foreach (var item in result)
  {
      Console.WriteLine(item);
  }
  Console.ReadKey();</code></pre><p><img src="/2019/11/05/Task返回值/1572942605519.png" alt="1572942605519"></p>
<h2 id="四：异常处理"><a href="#四：异常处理" class="headerlink" title="四：异常处理"></a>四：异常处理</h2><p>AggregateException是一个集合，因为task中可能回抛出多个异常，所以我们需要一种新的类型把这些异常都追加到一个集合种</p>
<h3 id="1。什么时候抛出异常？"><a href="#1。什么时候抛出异常？" class="headerlink" title="1。什么时候抛出异常？"></a>1。什么时候抛出异常？</h3><p>Task.Wait() or Tresult</p>
<h3 id="2-何时会有多个异常在AggregateException中？"><a href="#2-何时会有多个异常在AggregateException中？" class="headerlink" title="2.何时会有多个异常在AggregateException中？"></a>2.何时会有多个异常在AggregateException中？</h3><pre><code>    var task = Task.Factory.StartNew(()=&gt; {
        var child = Task.Factory.StartNew(() =&gt; {
            throw new Exception(&quot;我是child的异常&quot;);
        },TaskCreationOptions.AttachedToParent);
 var child2 = Task.Factory.StartNew(() =&gt; {
        throw new Exception(&quot;我是child2的异常&quot;);
    },TaskCreationOptions.AttachedToParent);
});
try
{
    task.Wait();
}
catch (AggregateException ex)
{
    foreach (var item in ex.InnerExceptions)
    {
        Console.WriteLine(string.Format(&quot;message:{0},type={1}&quot;, item.InnerException.Message, item.GetType().ToString()));
    }
}</code></pre><h3 id="3-Handle方法，就是处理当前的异常数组，判断上一层我当前哪些已经处理好了，没有处理好的，还需要向上抛出的？"><a href="#3-Handle方法，就是处理当前的异常数组，判断上一层我当前哪些已经处理好了，没有处理好的，还需要向上抛出的？" class="headerlink" title="3.Handle方法，就是处理当前的异常数组，判断上一层我当前哪些已经处理好了，没有处理好的，还需要向上抛出的？"></a>3.Handle方法，就是处理当前的异常数组，判断上一层我当前哪些已经处理好了，没有处理好的，还需要向上抛出的？</h3><p>Handle是用来便利异常数组，如果又一个异常信息是这样的，我任务已经处理，如果你觉得异常还需要往上抛，请返回fasle</p>
<p><img src="/2019/11/05/Task返回值/1572944579915.png" alt="1572944579915"><br>            try<br>                {<br>                    task.Wait();<br>                }<br>                catch (AggregateException ex)<br>                {<br>                    ex.Handle(x=&gt; {<br>                        return true;<br>                    });<br>                    return false;<br>                }</p>
]]></content>
      <categories>
        <category>线程</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Task取消</title>
    <url>/2019/11/05/Task%E5%8F%96%E6%B6%88/</url>
    <content><![CDATA[<h2 id="一：在Thread中做取消操作"><a href="#一：在Thread中做取消操作" class="headerlink" title="一：在Thread中做取消操作"></a>一：在Thread中做取消操作</h2><p>声明一个变量取去判断Thread中是否可以退出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool res = false;</span><br><span class="line">           var task = new Task(()=&gt; &#123;</span><br><span class="line">               while (!res)</span><br><span class="line">               &#123;</span><br><span class="line">                   Thread.Sleep(100);</span><br><span class="line">                   Console.WriteLine(&quot;当前Thread=&#123;0&#125;正在运行&quot;,Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">           task.Start();</span><br><span class="line">           Thread.Sleep(1000);</span><br><span class="line">           res = true;</span><br><span class="line">           Console.Read();</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/05/Task取消/1572915945633.png" alt="1572915945633"></p>
<p>不能让多个线程操作一个共享变量，否则会在release版本中有潜在bug</p>
<h2 id="二：task中有专门的类CancellationTokenSource去处理“任务取消”"><a href="#二：task中有专门的类CancellationTokenSource去处理“任务取消”" class="headerlink" title="二：task中有专门的类CancellationTokenSource去处理“任务取消”"></a>二：task中有专门的类CancellationTokenSource去处理“任务取消”</h2><h3 id="1-CancellationTokenSource远比一个变量强的多。"><a href="#1-CancellationTokenSource远比一个变量强的多。" class="headerlink" title="1.CancellationTokenSource远比一个变量强的多。"></a>1.CancellationTokenSource远比一个变量强的多。</h3><pre><code> CancellationTokenSource source = new CancellationTokenSource();
    var task = new Task(() =&gt; {
while (!source.IsCancellationRequested)
    {
        Thread.Sleep(100);
         Console.WriteLine(&quot;当前Thread={0}正在运行&quot;,Thread.CurrentThread.ManagedThreadId);
    }
 },source.Token);
task.Start();
Thread.Sleep(1000);
source.Cancel();</code></pre><p><img src="/2019/11/05/Task取消/1572916271694.png" alt="1572916271694"></p>
<p>效果同上</p>
<h3 id="2-当任务取消的时候，我希望有一个函数能够被触发，这个触发可以做一些资源的清理，又或者更新数据库信息"><a href="#2-当任务取消的时候，我希望有一个函数能够被触发，这个触发可以做一些资源的清理，又或者更新数据库信息" class="headerlink" title="2.当任务取消的时候，我希望有一个函数能够被触发，这个触发可以做一些资源的清理，又或者更新数据库信息"></a>2.当任务取消的时候，我希望有一个函数能够被触发，这个触发可以做一些资源的清理，又或者更新数据库信息</h3><pre><code>   CancellationTokenSource source = new CancellationTokenSource();
    source.Token.Register(()=&gt; {
        //如果当前token被取消，此函数被执行
        Console.WriteLine(&quot;当前想线程被取消，可以做资源清理！&quot;);
    });
var task = new Task(() =&gt; {

    while (!source.IsCancellationRequested)
    {
        Thread.Sleep(100);
         Console.WriteLine(&quot;当前Thread={0}正在运行&quot;,Thread.CurrentThread.ManagedThreadId);
    }
},source.Token);
task.Start();
Thread.Sleep(1000);
source.Cancel();</code></pre><p><img src="/2019/11/05/Task取消/1572916548220.png" alt="1572916548220"></p>
<h3 id="3-延时取消：我想2秒之后自动取消，或者N秒"><a href="#3-延时取消：我想2秒之后自动取消，或者N秒" class="headerlink" title="3.延时取消：我想2秒之后自动取消，或者N秒"></a>3.延时取消：我想2秒之后自动取消，或者N秒</h3><ul>
<li><p>source.CancelAfter(new TimeSpan(0,0,0,2));</p>
</li>
<li><p>CancellationTokenSource 构造函数： CancellationTokenSource source = new CancellationTokenSource(1000);</p>
</li>
<li><p>取消组合，将CancellationTokenSource 组成一个链表，其中任何一个CancellationTokenSource 被取消，组合也会被取消。var s3=s1&s2;</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CancellationTokenSource source1 = new CancellationTokenSource();</span><br><span class="line">         source1.Cancel();</span><br><span class="line">         CancellationTokenSource source2 = new CancellationTokenSource();</span><br><span class="line"></span><br><span class="line">         var source3 = CancellationTokenSource.CreateLinkedTokenSource(source1.Token, source2.Token);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         Console.WriteLine(&quot;s1=&#123;0&#125;,s2=&#123;1&#125;,s3=&#123;2&#125;&quot;,source1.IsCancellationRequested,source2.IsCancellationRequested,source3.IsCancellationRequested);</span><br></pre></td></tr></table></figure>

<p>加了source1.Cancel();</p>
<p><img src="/2019/11/05/Task取消/1572917962280.png" alt></p>
<p>不加source1.Cancel();</p>
<p><img src="/2019/11/05/Task取消/1572917999533.png" alt="1572917999533"></p>
<h3 id="4-ThrowIfCancellationRequested"><a href="#4-ThrowIfCancellationRequested" class="headerlink" title="4.ThrowIfCancellationRequested"></a>4.ThrowIfCancellationRequested</h3><pre><code>        CancellationTokenSource source1 = new CancellationTokenSource();
source1.Token.Register(()=&gt; {
               Console.WriteLine(&quot;当前想线程被取消，可以做资源清理！&quot;);
           });
       var task = Task.Factory.StartNew(() =&gt;
       {
           while (true)
           {
               source1.Token.ThrowIfCancellationRequested();
               Thread.Sleep(100);
               Console.WriteLine(&quot;当前Thread={0}正在运行&quot;, Thread.CurrentThread.ManagedThreadId);
           }
       }, source1.Token);
       Thread.Sleep(1000);
       source1.Cancel();

       Thread.Sleep(100);
       Console.WriteLine(task.Status);</code></pre><p><img src="/2019/11/05/Task取消/1572919032504.png" alt="1572919032504"></p>
]]></content>
      <categories>
        <category>线程</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Task的任务延续</title>
    <url>/2019/11/04/Task%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%BB%B6%E7%BB%AD/</url>
    <content><![CDATA[<h2 id="一：ContinueWith"><a href="#一：ContinueWith" class="headerlink" title="一：ContinueWith"></a>一：ContinueWith</h2><p>1.Task=&gt;Task.CreationOptions  第一task</p>
<p>2.Task=&gt;TaskContinuationOptions 第二个task</p>
<p>第二个task需要判断第一个task在什么情况下，我该执行或者不该执行。。</p>
<h2 id="二：LazyCancellation"><a href="#二：LazyCancellation" class="headerlink" title="二：LazyCancellation"></a>二：LazyCancellation</h2><p>1.Cancellation判断任务的取消。。。相当于Thread about</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CancellationTokenSource source = new CancellationTokenSource();//判断任务延续</span><br><span class="line">           source.Cancel();</span><br><span class="line">           Task task1 = new Task(() =&gt; &#123;</span><br><span class="line">               //Thread.Sleep(1000);</span><br><span class="line">               Console.WriteLine(&quot;task1, tid=&#123;0&#125;,dt=&#123;1&#125;&quot;, Thread.CurrentThread.ManagedThreadId, DateTime.Now.ToString(&quot;HH:mm:ss&quot;));</span><br><span class="line">           &#125;);</span><br><span class="line">           var task2 = task1.ContinueWith(t =&gt; &#123;</span><br><span class="line">               Console.WriteLine(&quot;task2,tid=&#123;0&#125;,dt=&#123;1&#125;&quot;, Thread.CurrentThread.ManagedThreadId, DateTime.Now.ToString(&quot;HH:mm:ss&quot;));</span><br><span class="line">           &#125;, source.Token);</span><br><span class="line">           var task3 = task2.ContinueWith(t =&gt; &#123;</span><br><span class="line"></span><br><span class="line">               Console.WriteLine(&quot;task3,tid=&#123;0&#125;,dt=&#123;1&#125;,task2=&#123;2&#125;&quot;, Thread.CurrentThread.ManagedThreadId, DateTime.Now.ToString(&quot;HH:mm:ss&quot;), task2.Status);</span><br><span class="line">           &#125;);</span><br><span class="line">           task1.Start();</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/04/Task的任务延续/1572882571897.png" alt="1572882705464"></p>
<p>正常执行顺序：task1-&gt;ContinueWith task2-&gt;ContinueWith task3</p>
<p>结果执行顺序： task3-&gt;task1</p>
<p>解释：ContinueWith的时候，预先判断了source.Token的值，结果发现任务已经取消，这个时候，task2和task1没有延续的关系，所以task3和task1可以并行，看似ContinueWith的关系得不到延续【并行】</p>
<p><img src="/2019/11/04/Task的任务延续/1572882940405.png" alt="1572882940405"></p>
<p>使用TaskContinuationOptions.LazyCancellation</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CancellationTokenSource source = new CancellationTokenSource();//判断任务延续</span><br><span class="line">          source.Cancel();</span><br><span class="line">          Task task1 = new Task(() =&gt; &#123;</span><br><span class="line">              //Thread.Sleep(1000);</span><br><span class="line">              Console.WriteLine(&quot;task1, tid=&#123;0&#125;,dt=&#123;1&#125;&quot;, Thread.CurrentThread.ManagedThreadId, DateTime.Now.ToString(&quot;HH:mm:ss&quot;));</span><br><span class="line">          &#125;);</span><br><span class="line">          var task2 = task1.ContinueWith(t =&gt; &#123;</span><br><span class="line">              Console.WriteLine(&quot;task2,tid=&#123;0&#125;,dt=&#123;1&#125;&quot;, Thread.CurrentThread.ManagedThreadId, DateTime.Now.ToString(&quot;HH:mm:ss&quot;));</span><br><span class="line">          &#125;, source.Token,TaskContinuationOptions.LazyCancellation, TaskScheduler.Current);</span><br><span class="line">          var task3 = task2.ContinueWith(t =&gt; &#123;</span><br><span class="line">              Console.WriteLine(&quot;task3,tid=&#123;0&#125;,dt=&#123;1&#125;,task2=&#123;2&#125;&quot;, Thread.CurrentThread.ManagedThreadId, DateTime.Now.ToString(&quot;HH:mm:ss&quot;), task2.Status);</span><br><span class="line">          &#125;);</span><br><span class="line">          task1.Start();</span><br><span class="line">          Console.Read();</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/04/Task的任务延续/1572883135949.png" alt="1572883135949"></p>
<p>TaskContinuationOptions.LazyCancellation当task2被取消了，还是先执行等待线程执行完成，在执行后面的线程</p>
<h2 id="三：ExecuteSynchronously"><a href="#三：ExecuteSynchronously" class="headerlink" title="三：ExecuteSynchronously"></a>三：ExecuteSynchronously</h2><p>同步执行任务，2个线程用同一个线程执行，可以减少时间片切换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Task task1 = new Task(() =&gt; &#123;</span><br><span class="line">              Thread.Sleep(1000);</span><br><span class="line">              Console.WriteLine(&quot;task1, tid=&#123;0&#125;,dt=&#123;1&#125;&quot;, Thread.CurrentThread.ManagedThreadId, DateTime.Now.ToString(&quot;HH:mm:ss&quot;));</span><br><span class="line">          &#125;);</span><br><span class="line">          var task2 = task1.ContinueWith(t =&gt; &#123;</span><br><span class="line">              Console.WriteLine(&quot;task2,tid=&#123;0&#125;,dt=&#123;1&#125;&quot;, Thread.CurrentThread.ManagedThreadId, DateTime.Now.ToString(&quot;HH:mm:ss&quot;));</span><br><span class="line">          &#125;,TaskContinuationOptions.ExecuteSynchronously);</span><br><span class="line">          var task3 = task2.ContinueWith(t =&gt; &#123;</span><br><span class="line">              Console.WriteLine(&quot;task3,tid=&#123;0&#125;,dt=&#123;1&#125;,task2=&#123;2&#125;&quot;, Thread.CurrentThread.ManagedThreadId, DateTime.Now.ToString(&quot;HH:mm:ss&quot;), task2.Status);</span><br><span class="line">          &#125;);</span><br><span class="line">          task1.Start();</span><br><span class="line">          Console.Read();</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/04/Task的任务延续/1572883421282.png" alt="1572883421282"></p>
<p>上图使用TaskContinuationOptions.ExecuteSynchronously，task1和task2使用同一个线程执行任务。</p>
<p>不使用TaskContinuationOptions.ExecuteSynchronously的结果:</p>
<p><img src="/2019/11/04/Task的任务延续/1572883467747.png" alt="1572883467747"></p>
<h2 id="四：NotOnRanToCompletion和OnlyOnRanToCompletion"><a href="#四：NotOnRanToCompletion和OnlyOnRanToCompletion" class="headerlink" title="四：NotOnRanToCompletion和OnlyOnRanToCompletion"></a>四：NotOnRanToCompletion和OnlyOnRanToCompletion</h2><p>前者表示延续任务必须在非完成状态才能执行</p>
<p>后者表示延续任务必须在完成状态才能执行</p>
<h2 id="五：NotOnFaulted和OnlyOnFaulted"><a href="#五：NotOnFaulted和OnlyOnFaulted" class="headerlink" title="五：NotOnFaulted和OnlyOnFaulted"></a>五：NotOnFaulted和OnlyOnFaulted</h2><p>前者表示延续任务必须在非失败状态才能执行</p>
<p>后者表示延续任务必须在失败状态才能执行</p>
<h2 id="六：NotOnCanceled和OnlyOnCanceled"><a href="#六：NotOnCanceled和OnlyOnCanceled" class="headerlink" title="六：NotOnCanceled和OnlyOnCanceled"></a>六：NotOnCanceled和OnlyOnCanceled</h2><p>前者表示延续任务必须在非取消状态才能执行</p>
<p>后者表示延续任务必须在取消状态才能执行</p>
]]></content>
      <categories>
        <category>线程</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Task常见的枚举</title>
    <url>/2019/11/04/Task%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<p>一：Task中的枚举</p>
<pre><code>None = 0,
PreferFairness = 1,
LongRunning = 2,
AttachedToParent = 4,
DenyChildAttach = 8,
HideScheduler = 16,
RunContinuationsAsynchronously = 64</code></pre><p>二：任务延续中的枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">None = 0,</span><br><span class="line">PreferFairness = 1,</span><br><span class="line">LongRunning = 2,</span><br><span class="line">AttachedToParent = 4,</span><br><span class="line">DenyChildAttach = 8,</span><br><span class="line">HideScheduler = 16,</span><br><span class="line">LazyCancellation = 32,</span><br><span class="line">RunContinuationsAsynchronously = 64,</span><br><span class="line">NotOnRanToCompletion = 65536,</span><br><span class="line">NotOnFaulted = 131072,</span><br><span class="line">NotOnCanceled = 262144,</span><br><span class="line">OnlyOnRanToCompletion = 393216,</span><br><span class="line">OnlyOnFaulted = 327680,</span><br><span class="line">OnlyOnCanceled = 196608,</span><br><span class="line">ExecuteSynchronously = 524288</span><br></pre></td></tr></table></figure>

<p>三：演示</p>
<p>TaskCreationOptions:</p>
<p>1.AttachedToParent:子线程和父线程同步</p>
<pre><code>Task task = new Task(() =&gt;
        {

            Task task1 = new Task(() =&gt;
            {
                Thread.Sleep(100);
                Console.WriteLine(&quot;task1&quot;);

            }, TaskCreationOptions.AttachedToParent);

            Task task2 = new Task(() =&gt;
            {
                Thread.Sleep(10);
                Console.WriteLine(&quot;task2&quot;);
            }, TaskCreationOptions.AttachedToParent);
            task1.Start();
            task2.Start();
        });
        task.Start();
        task.Wait();
        Console.WriteLine(&quot;我是主线程&quot;);</code></pre><p><img src="/2019/11/04/Task常见的枚举/1572837904340.png" alt="1572837904340"></p>
<p>2.DenyChildAttach:不让子任务附加到父任务中</p>
<p> Task task = new Task(() =&gt;<br>            {</p>
<pre><code>    Task task1 = new Task(() =&gt;
    {
        Thread.Sleep(100);
        Console.WriteLine(&quot;task1&quot;);

    }, TaskCreationOptions.AttachedToParent);

    Task task2 = new Task(() =&gt;
    {
        Thread.Sleep(10);
        Console.WriteLine(&quot;task2&quot;);
    }, TaskCreationOptions.AttachedToParent);
    task1.Start();
    task2.Start();
}, TaskCreationOptions.DenyChildAttach);
task.Start();
task.Wait();
Console.WriteLine(&quot;我是主线程&quot;);</code></pre><p><img src="/2019/11/04/Task常见的枚举/1572838075737.png" alt="1572838075737"></p>
<p>3.HideScheduler:子任务默认不调用父类的Task的Scheduler，而是使用默认的</p>
<p>4.LongRunning：长时间运行的任务，建议使用此选项，或者建议使用Thread而不是ThreadPool,如果长期租用不还给ThreadPool,ThreadPool会开启新的线程，如果此时租用线程归还，这回导致ThreadPool线程过多，销毁和调度都是一个很大的麻烦。</p>
<pre><code>Task task1 = new Task(() =&gt;
    {
        Thread.Sleep(100);
        Console.WriteLine(&quot;task1&quot;);
    }, TaskCreationOptions.LongRunning);
    task1.Start();
    task1.Wait();
    Console.WriteLine(&quot;我是主线程！！！&quot;);
    Console.Read();</code></pre><p><img src="/2019/11/04/Task常见的枚举/1572838876190.png" alt="1572838876190"></p>
<p>5.PreferFairness:会将Task放入到ThreadPool的全局变量中，让word thread进行争抢，默认情况会放到task的一个本地队列中。</p>
]]></content>
      <categories>
        <category>线程</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Task7种阻塞方式</title>
    <url>/2019/11/04/Task7%E7%A7%8D%E9%98%BB%E5%A1%9E%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="一：Task的阻塞和延续操作"><a href="#一：Task的阻塞和延续操作" class="headerlink" title="一：Task的阻塞和延续操作"></a>一：Task的阻塞和延续操作</h2><p>1.阻塞</p>
<p>在Thread=&gt;使用Join方法阻塞</p>
<p>Thread:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread t = new Thread(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(1000);</span><br><span class="line">            Console.WriteLine(&quot;我是工作线程1&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = new Thread(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            Thread.Sleep(1000);</span><br><span class="line">            Console.WriteLine(&quot;我是工作线程2&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        t2.Start();</span><br><span class="line">        t.Start();</span><br><span class="line"></span><br><span class="line">        t2.Join();</span><br><span class="line">        t.Join();</span><br></pre></td></tr></table></figure>

<p>每等待一个，需要Join()一下，线程多了以后，就繁琐了！</p>
<p>Task:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Task task1 = new Task(()=&gt; &#123;</span><br><span class="line">               Thread.Sleep(1000);</span><br><span class="line">              Console.WriteLine(&quot;我是工作线程1:&#123;0&#125;&quot;,                 DateTime.Now.ToString(&quot;hh:mm:ss&quot;));</span><br><span class="line">          &#125;);</span><br><span class="line">          task1.Start();</span><br><span class="line">          Task task2 = new Task(() =&gt; &#123;</span><br><span class="line">              Thread.Sleep(2000);</span><br><span class="line">              Console.WriteLine(&quot;我是工作线程2:&#123;0&#125;&quot;, DateTime.Now.ToString(&quot;hh:mm:ss&quot;));</span><br><span class="line">          &#125;);</span><br><span class="line">          task2.Start();</span><br><span class="line">          Task.WhenAll(task1, task2);</span><br></pre></td></tr></table></figure>

<p>2.Task.WaitAll():是一种&amp;&amp;关系<strong>[必须其中所有的Task完成才算完成]</strong></p>
<p>3.Task.WaitAny():是一种||关系<strong>[其中有一个Task完成就算完成]</strong></p>
<p>4.Task.Wait()==join()</p>
<p>5.Task.WhenAll(task1,task2).ContinueWith();执行延续任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Task task1 = new Task(()=&gt; &#123;</span><br><span class="line">                 Thread.Sleep(1000);</span><br><span class="line">                Console.WriteLine(&quot;我是工作线程1:&#123;0&#125;&quot;, DateTime.Now.ToString(&quot;hh:mm:ss&quot;));</span><br><span class="line">            &#125;);</span><br><span class="line">            task1.Start();</span><br><span class="line">            Task task2 = new Task(() =&gt; &#123;</span><br><span class="line">                Thread.Sleep(2000);</span><br><span class="line">                Console.WriteLine(&quot;我是工作线程2:&#123;0&#125;&quot;, DateTime.Now.ToString(&quot;hh:mm:ss&quot;));</span><br><span class="line">            &#125;);</span><br><span class="line">            task2.Start();</span><br><span class="line">            //------------------------------------上面的等待返回值都是void</span><br><span class="line">            Task.WhenAll(task1, task2).ContinueWith(t=&gt; &#123;</span><br><span class="line">                //执行工作线程3</span><br><span class="line">                Console.WriteLine(&quot;我是主线程:&#123;0&#125;&quot;, DateTime.Now.ToString(&quot;hh:mm:ss&quot;));</span><br><span class="line">            &#125;);</span><br><span class="line">            Console.Read();</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/04/Task7种阻塞方式/1572830032942.png" alt="1572830032942"></p>
<p>6.Task.Factory.ContinueWhenAll();</p>
<p>7.Task.Factory.ContinueWhenAny();</p>
]]></content>
      <categories>
        <category>线程</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Task</title>
    <url>/2019/11/04/Task/</url>
    <content><![CDATA[<h2 id="一：Task-在-net-4-0版本使用"><a href="#一：Task-在-net-4-0版本使用" class="headerlink" title="一：Task(在.net 4.0版本使用)"></a>一：Task(在.net 4.0版本使用)</h2><ul>
<li>Task=&gt;Thread+ThreadPool</li>
<li>Thread:容易造成时间+空间开销，而且使用不当，容易造成线程过多，导致时间片切换</li>
<li>ThreadPool:控制能力比较弱，做Thread的延续，阻塞，取消，超时等等功能。控制权在CLR，而不是在我们手上。</li>
</ul>
<p>Task是基于ThreadPool的基础上进行的封装，.net4..0之后，微软主推Task做异步启动。</p>
<h2 id="二：Task的启动方式"><a href="#二：Task的启动方式" class="headerlink" title="二：Task的启动方式"></a>二：Task的启动方式</h2><p>1.实例化启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Task task = new Task(() =&gt;</span><br><span class="line">           &#123;</span><br><span class="line">               Console.WriteLine(&quot;我是工作线程，tid=&#123;0&#125;&quot;, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">           &#125;);</span><br><span class="line">           task.Start();</span><br></pre></td></tr></table></figure>

<p>2.工程模式(Task.Factory启动)</p>
<pre><code>var task = Task.Factory.StartNew(() =&gt;
{
    Console.WriteLine(&quot;我是工作线程，tid={0}&quot;, Thread.CurrentThread.ManagedThreadId);
});</code></pre><p>3.使用Task的Run方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var task = Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(&quot;我是工作线程，tid=&#123;0&#125;&quot;, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>4.同步（阻塞线程，同步执行）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var task = new Task(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(&quot;我是工作线程，tid=&#123;0&#125;&quot;, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">&#125;);</span><br><span class="line">task.RunSynchronously();</span><br></pre></td></tr></table></figure>

<p>三：Task是建立在ThreadPool</p>
<p>实例化Task在Windgb下的状态：</p>
<p><img src="/2019/11/04/Task/1572827768283.png" alt="1572827768283"></p>
<p>同步（阻塞线程，同步执行）在Windbg下的状态：</p>
<p><img src="/2019/11/04/Task/1572827872739.png" alt="1572827872739"></p>
<p>很明显看出：</p>
<ul>
<li>Task的底层就是ThreadPool,ThreadPool分配了2个线程，属于CLR所有</li>
<li>同步就没有其他线程，当线程执行完，才执行主线程</li>
</ul>
<p>Task底层都是由不同的TaskScheduler支撑的</p>
<p>TaskScheduler相当于Task的CPU处理器</p>
<p>默认的TaskScheduler是ThreadPoolTaskScheduler</p>
<h2 id="四：Task具有返回值"><a href="#四：Task具有返回值" class="headerlink" title="四：Task具有返回值"></a>四：Task具有返回值</h2><pre><code>var task = new Task&lt;string&gt;(() =&gt;
{
    return &quot;Hello Word!&quot;;
});
task.Start();
Console.WriteLine(task.Result);</code></pre><p><img src="/2019/11/04/Task/1572828794968.png" alt="1572828794968"></p>
]]></content>
      <categories>
        <category>线程</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Thread定时器</title>
    <url>/2019/11/03/Thread%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<h2 id="一-定时器-（可以想到Time）"><a href="#一-定时器-（可以想到Time）" class="headerlink" title="一.定时器 （可以想到Time）"></a>一.定时器 （可以想到Time）</h2><h3 id="1-ThreadPool的定时器功能："><a href="#1-ThreadPool的定时器功能：" class="headerlink" title="1.ThreadPool的定时器功能："></a>1.ThreadPool的定时器功能：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ThreadPool.RegisterWaitForSingleObject(new AutoResetEvent(true), new WaitOrTimerCallback((obj, b) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">     Console.WriteLine(&quot;obj=&#123;0&#125;,tid=&#123;1&#125;,datetime=&#123;2&#125;&quot;, obj,           Thread.CurrentThread.ManagedThreadId, DateTime.Now.ToString(&quot;hh:MM:ss&quot;));</span><br><span class="line">        &#125;), &quot;hello word&quot;, 1000, false);</span><br></pre></td></tr></table></figure>

<p>RegisterWaitForSingleObject():</p>
<p>1.(new AutoResetEvent(true):两个线程之间进行信号发送，当true无需等待，当为false,会等待1秒</p>
<p>False:</p>
<p><img src="/2019/11/03/Thread定时器/1572776249485.png" alt="1572776249485"></p>
<p>True:</p>
<p><img src="/2019/11/03/Thread定时器/1572776292652.png" alt></p>
<p>2.new WaitOrTimerCallback():回调函数</p>
<p>3.”hello word”：传递参数</p>
<p>4.1000：定时器执行的间隔（单位毫秒）</p>
<p>5.false:是否仅执行一次</p>
<p>6.debug执行的效果如下：</p>
<p><img src="/2019/11/03/Thread定时器/D:%5Chexo%5Csource_posts%5CThread%E5%AE%9A%E6%97%B6%E5%99%A8%5C1572776606802.png" alt></p>
<p><img src="/2019/11/03/Thread定时器/1572776650195.png" alt></p>
<h3 id="2-Timer"><a href="#2-Timer" class="headerlink" title="2.Timer"></a>2.Timer</h3><p>有很多地方都有Timer:</p>
<ul>
<li>System.Threading</li>
<li>System.Timer</li>
<li>System.Windows.Form</li>
<li>System.Web.UI</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Timer timer = new Timer(new TimerCallback((obj) =&gt;</span><br><span class="line">       &#123;</span><br><span class="line">           Console.WriteLine(&quot;obj=&#123;0&#125;,tid=&#123;1&#125;,datetime=&#123;2&#125;&quot;, obj, Thread.CurrentThread.ManagedThreadId, DateTime.Now.ToString(&quot;hh:MM:ss&quot;));</span><br><span class="line">       &#125;), &quot;hello word&quot;, 1000, 1000);</span><br></pre></td></tr></table></figure>

<p>1.new TimerCallback();回调函数</p>
<p>2.“hello word”：传递参数</p>
<p>3.1000：延迟执行的时间【单位毫秒】</p>
<p>4.1000：线程执行的时间间隔</p>
<p><img src="/2019/11/03/Thread定时器/1572777324601.png" alt></p>
<p>Timer首先是用ThreadPool.<strong>UnsafeQueueUserWorkItem</strong>(waitCallback, timer);来完成定时功能。</p>
<h2 id="三：实战开发中，基本上不会用Timer来处理问题"><a href="#三：实战开发中，基本上不会用Timer来处理问题" class="headerlink" title="三：实战开发中，基本上不会用Timer来处理问题"></a>三：实战开发中，基本上不会用Timer来处理问题</h2><p>功能太少。</p>
<p>比如，每天早上8点启动一个线程，逻辑太多计算时间，开销大，费时费力。</p>
<h2 id="四：开源框架解决定时的问题：Quarz-net"><a href="#四：开源框架解决定时的问题：Quarz-net" class="headerlink" title="四：开源框架解决定时的问题：Quarz.net"></a>四：开源框架解决定时的问题：Quarz.net</h2>]]></content>
      <categories>
        <category>线程</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadPool</title>
    <url>/2019/11/03/ThreadPool/</url>
    <content><![CDATA[<h2 id="一：Thread是CLR表示线程的数据结构"><a href="#一：Thread是CLR表示线程的数据结构" class="headerlink" title="一：Thread是CLR表示线程的数据结构"></a><strong>一：Thread是CLR表示线程的数据结构</strong></h2><h2 id="二：ThreadPool线程池"><a href="#二：ThreadPool线程池" class="headerlink" title="二：ThreadPool线程池"></a>二：ThreadPool线程池</h2><ul>
<li>Thread:做一个异步任务，就需要开启一个Thread.[专有性]</li>
<li>ThreadPool:想做异步任务，打个比方，租车公司：租完车需要归还。</li>
</ul>
<h2 id="三：ThreadPool的使用方式"><a href="#三：ThreadPool的使用方式" class="headerlink" title="三：ThreadPool的使用方式"></a>三：ThreadPool的使用方式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ThreadPool.QueueUserWorkItem((obj)=&gt; &#123;</span><br><span class="line">               var func = obj as Func&lt;string&gt;;</span><br><span class="line">               Console.WriteLine(&quot;我是工作线程:&#123;0&#125;,content=&#123;1&#125;&quot;,Thread.CurrentThread.ManagedThreadId,func());</span><br><span class="line">           &#125;,new Func&lt;string&gt;(()=&gt;&quot;Hello World&quot;));</span><br><span class="line"></span><br><span class="line">           Console.WriteLine(&quot;主线程ID:&#123;0&#125;&quot;,Thread.CurrentThread.ManagedThreadId);</span><br></pre></td></tr></table></figure>

<h2 id="四：Thread和ThreadPool到底多少区别"><a href="#四：Thread和ThreadPool到底多少区别" class="headerlink" title="四：Thread和ThreadPool到底多少区别"></a>四：Thread和ThreadPool到底多少区别</h2><h3 id="1-如果现在有10个任务："><a href="#1-如果现在有10个任务：" class="headerlink" title="1.如果现在有10个任务："></a>1.如果现在有10个任务：</h3><ul>
<li>Thread:需要开启10个任务</li>
<li>Thread:10个任务放进线程池</li>
</ul>
<h3 id="2-区别"><a href="#2-区别" class="headerlink" title="2.区别"></a>2.区别</h3><h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread:"></a>Thread:</h3><p><img src="/2019/11/03/ThreadPool/1572773284491.png" alt></p>
<p>线程数量：12个，未启动线程：0个，后台线程：1个，待处理线程：0个，死线程：10个。</p>
<p>XXXX表示线程死了，会进到终结器，GC会在下一次回收，会占用1M的堆栈空间。</p>
<p>执行命令:</p>
<p>!FinalizeQueue</p>
<p><img src="/2019/11/03/ThreadPool/1572773908521.png" alt></p>
<p>可以看到有11线程进入终结器</p>
<h3 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool:"></a>ThreadPool:</h3><p><img src="/2019/11/03/ThreadPool/1572772113309.png" alt></p>
<p>ThreadCount:一共有6个线程，一个主线程，一个寄存器，4个工作线程</p>
<p><img src="/2019/11/03/ThreadPool/1572772218650.png" alt></p>
<p><strong>Cpu利用率30%，工作线程数量4个，在运行的线程为0，空闲的线程是4个，最大的线程是2047，最小的是4个</strong></p>
<p><strong>工作线程的队列是0个</strong></p>
<p><strong>IO线程端口线程0个，空闲0个，最大空闲8个，最大线程1000个，最小线程4个。</strong></p>
<p>当前ThreadPool中，有“工作线程”和“IO线程”</p>
<p>工作线程：给一般的异步任务执行的。其中 不涉及网络，文件等IO操作。【开发调用】</p>
<p>IO线程：一般用在文件和网络IO上。【CLR调用】</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><h3 id="1-ThreadPool可以用8个线程解决10个线程干的事情："><a href="#1-ThreadPool可以用8个线程解决10个线程干的事情：" class="headerlink" title="1.ThreadPool可以用8个线程解决10个线程干的事情："></a>1.ThreadPool可以用8个线程解决10个线程干的事情：</h3><p>节省了空间和时间：</p>
<p>时间：通过各个托管和非托管的dll</p>
<p>空间：teb,osthread结构，堆栈</p>
]]></content>
      <categories>
        <category>线程</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Thread静态方法</title>
    <url>/2019/10/31/Thread%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="Thread静态方法"><a href="#Thread静态方法" class="headerlink" title=".Thread静态方法"></a>.Thread静态方法</h2><h2 id="一-Thread静态方法"><a href="#一-Thread静态方法" class="headerlink" title="一.Thread静态方法"></a>一.Thread静态方法</h2><h6 id="1-主线程上设置槽位，也是Hello-Word-只能被主线程读取，其他线程无法读取"><a href="#1-主线程上设置槽位，也是Hello-Word-只能被主线程读取，其他线程无法读取" class="headerlink" title="1.主线程上设置槽位，也是Hello Word!只能被主线程读取，其他线程无法读取"></a>1.主线程上设置槽位，也是Hello Word!只能被主线程读取，其他线程无法读取</h6><p>Thread.AllocateDataSlot();<strong>分配未命名的槽位</strong></p>
<p>var solt =Thread.AllocateNamedDataSlot(“username”);<strong>分配命名的槽位</strong></p>
<p>Thread.SetData(solt, “Hello Word!”);<strong>设置槽位的值</strong></p>
<p>var obj2 = Thread.GetData(solt);<strong>获取槽位的值</strong></p>
<p>Thread.FreeNamedDataSlot(“username”);<strong>释放槽位</strong></p>
<h6 id="2-ThreadStatic-：设置线程字段的唯一"><a href="#2-ThreadStatic-：设置线程字段的唯一" class="headerlink" title="2.[ThreadStatic]：设置线程字段的唯一"></a>2.[ThreadStatic]：<u>设置线程字段的唯一</u></h6><h6 id="3-ThreadLocal：提供线程的本地存储线程可见"><a href="#3-ThreadLocal：提供线程的本地存储线程可见" class="headerlink" title="3.ThreadLocal：提供线程的本地存储线程可见"></a>3.ThreadLocal<t>：<u>提供线程的本地存储</u>线程可见</t></h6><h6 id="4-TLS-thread-local-storage-线程本地存储"><a href="#4-TLS-thread-local-storage-线程本地存储" class="headerlink" title="4.TLS:thread local storage[线程本地存储]"></a>4.TLS:thread local storage[线程本地存储]</h6><h2 id="二-Thread静态方法【内存栅栏】"><a href="#二-Thread静态方法【内存栅栏】" class="headerlink" title="二.Thread静态方法【内存栅栏】"></a>二.Thread静态方法【内存栅栏】</h2><p>1.Thread.MemoryBarrier();</p>
]]></content>
      <categories>
        <category>线程</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Thread实例方法</title>
    <url>/2019/10/29/Thread%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="Thread实例方法"><a href="#Thread实例方法" class="headerlink" title="Thread实例方法"></a>Thread实例方法</h2><p>1.Thread的生命周期(join阻塞主线程)</p>
<ul>
<li>Start()：启动。</li>
<li>Suspend()：暂停。</li>
<li>Resume()：挂起。</li>
<li>Interrupt()：中断（用来中断处于出于WaitSleepJoin状态的线程），相当continue;。</li>
<li>About()：中断线程（通过抛出异常的销毁一个线程）,相当于break</li>
<li>Join:阻塞主线程，等待子线程执行完后。</li>
</ul>
<p>2.</p>
]]></content>
      <categories>
        <category>线程</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Thread基础</title>
    <url>/2019/10/28/Thread%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Thread的基础知识"><a href="#Thread的基础知识" class="headerlink" title="Thread的基础知识"></a>Thread的基础知识</h1><h2 id="一-空间的开销"><a href="#一-空间的开销" class="headerlink" title="一.空间的开销"></a>一.空间的开销</h2><h3 id="1-Thread可以理解为操作系统的概率"><a href="#1-Thread可以理解为操作系统的概率" class="headerlink" title="1.Thread可以理解为操作系统的概率"></a>1.Thread可以理解为操作系统的概率</h3><p>   Thread的内核数据结构，其中有osid,context=&gt;cpu寄存器的里面的一些变量.</p>
<p>​    <strong><u>时间片切换，切换间隔30ms</u></strong></p>
<h3 id="2-Thread环境块"><a href="#2-Thread环境块" class="headerlink" title="2.Thread环境块"></a>2.Thread环境块</h3><p> TLS[thread本地存储]，ExecptionList的信息</p>
<p>工具：<a href="https://down.52pojie.cn/Tools/Debuggers/WinDbg_X64_v10.0.16299.15.msi" target="_blank" rel="noopener">WinDbg</a></p>
<p>功能：查看底层，线程的信息，如主线程,结束线程，OSID,终结器等！</p>
<p>命令:</p>
<ul>
<li>.loadby sos clr:对于.Net Runtime 4.0,加载所有的DLL</li>
<li>!threads: 查看托管线程</li>
<li>!teb:列出结构_TEB的成员信息</li>
<li>!dumpdomain:查看程序域</li>
</ul>
<h3 id="3-用户模式堆栈：内存溢出的一个异常【堆栈溢出】"><a href="#3-用户模式堆栈：内存溢出的一个异常【堆栈溢出】" class="headerlink" title="3.用户模式堆栈：内存溢出的一个异常【堆栈溢出】"></a>3.用户模式堆栈：内存溢出的一个异常【堆栈溢出】</h3><p>​     一个线程分配1m的堆栈空间，存放【参数，局部变量】</p>
<h3 id="4-内核模式堆栈"><a href="#4-内核模式堆栈" class="headerlink" title="4.内核模式堆栈"></a>4.内核模式堆栈</h3><p>​     在CLR的线程操作，包括线程同步，大多数调用底层的Win32函数，用户模式的参数需要传递到内核模式。</p>
<h2 id="二-时间开销"><a href="#二-时间开销" class="headerlink" title="二.时间开销"></a>二.时间开销</h2><h4 id="1-我们的Application启动的时候，回加载很多的dll【托管和非托管】-exe-资源，元数据"><a href="#1-我们的Application启动的时候，回加载很多的dll【托管和非托管】-exe-资源，元数据" class="headerlink" title="1.我们的Application启动的时候，回加载很多的dll【托管和非托管】,exe,资源，元数据"></a>1.我们的Application启动的时候，回加载很多的dll【托管和非托管】,exe,资源，元数据</h4><p>   进程启动时候为什么我没看到应用程序域？</p>
<p>   答：进程启动回默认启动3个应用程序域。System domain,shared domain,domain</p>
<hr>
<p>开启一个thread,销毁一个thread都会通知进程中的dll,attach,detach标志位</p>
<p>通知dll的目的就是给thread做准备工作，比如销毁，让这些dll做资源清理</p>
<h4 id="2-时间片切换"><a href="#2-时间片切换" class="headerlink" title="2.时间片切换"></a>2.时间片切换</h4><p>   4个逻辑处理器，可提供4个thread并行执行</p>
<p>  <img src="/2019/10/28/Thread基础/1572279645799.png" alt></p>
<p>执行5个thread，就有个一个thread休眠30ms</p>
]]></content>
      <categories>
        <category>线程</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>委托的概念</title>
    <url>/2019/10/17/%E5%A7%94%E6%89%98%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="1-委托的概念"><a href="#1-委托的概念" class="headerlink" title="1.委托的概念"></a>1.委托的概念</h1><p>​       委托是一个<strong>类</strong>，它定义了<strong>方法的类型</strong>，使得可以<strong>将方法当作另一个方法的参数来进行传递</strong>，这种将方法<strong>动态地赋给参数的做法</strong>，可以避免在程序中大量使用If-Else(Switch)语句，同时使得程序具有更好的可扩展性。委托是一个<strong>引用类型</strong>，委托看成是用来执行方法（函数）的一个东西。</p>
<h1 id="2-委托的声明和定义"><a href="#2-委托的声明和定义" class="headerlink" title="2.委托的声明和定义"></a>2.委托的声明和定义</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public delegate int MyFirstDelegate (string s);</span><br></pre></td></tr></table></figure>

<h1 id="3-委托的方法"><a href="#3-委托的方法" class="headerlink" title="3.委托的方法"></a>3.委托的方法</h1><p>Invoke（同步）</p>
<p>BeginInvoke(异步)</p>
<p>EndInvoke(异步回调)</p>
<p>可以参考学习这个：<a href="https://blog.csdn.net/ydm19891101/article/details/50069491" target="_blank" rel="noopener">委托的invoke、beginInvoke和控件的invoke、beginInvoke的区别</a></p>
<h1 id="4-代码模块"><a href="#4-代码模块" class="headerlink" title="4.代码模块"></a>4.代码模块</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//代码清单2-1 以各种简单的方式使用委托</span><br><span class="line">delegate void StringProcessor(string input);//声明委托类型</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    public Person(string name) &#123; this.name = name; &#125;</span><br><span class="line">    //声明兼容的实例方法</span><br><span class="line">    public void Say(string message)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;&#123;0&#125;说:&#123;1&#125;&quot;,name,message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class BackGround</span><br><span class="line">&#123;</span><br><span class="line">    //声明兼容的静态方法</span><br><span class="line">    public static void Note(string note)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;（&#123;0&#125;）&quot;,note);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">        //声明人物实例</span><br><span class="line">        Person jon = new Person(&quot;铁子&quot;);</span><br><span class="line">        Person tom = new Person(&quot;杨树&quot;);</span><br><span class="line">        //声明委托实例，并添加对应的实例方法和静态方法</span><br><span class="line">        StringProcessor jonsVoice, tomsVoice, background;</span><br><span class="line">        jonsVoice = new StringProcessor(jon.Say);</span><br><span class="line">        tomsVoice = new StringProcessor(tom.Say);</span><br><span class="line">        background = new StringProcessor(BackGround.Note);</span><br><span class="line">        //调用委托实例</span><br><span class="line">        jonsVoice(&quot;你瞅啥？&quot;);</span><br><span class="line">        tomsVoice.Invoke(&quot;瞅你咋地？&quot;);</span><br><span class="line">        background(&quot;烧烤摊又开始洋溢着欢快的声音了&quot;);</span><br><span class="line">        Console.Read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>委托</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL面试题</title>
    <url>/2019/10/15/SQL%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>C#面试题</title>
    <url>/2019/10/15/C-%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p><strong>1.维护数据库的完整性、一致性、你喜欢用触发器还是自写业务逻辑？为什么?</strong></p>
<p>答：尽可能用约束（包括CHECK、主键、唯一键、外键、非空字段）实现，这种方式的效率最好；其次用触发器，这种方式可以保证无论何种业务系统访问数据库都能维持数据库的完整性、一致性；最后再考虑用自写业务逻辑实现，但这种方式效率最低、编程最复杂，当为下下之策。</p>
<p><strong>2.什么是事务？什么是锁？</strong></p>
<p>答：事务是指一个<strong>工作单元</strong>，它包含了一组<strong>数据操作命令</strong>，并且所有的命令作为一个整体一起向系统<strong>提交或撤消</strong>请求操作，即这组命令要么都执行，要么都不执行。</p>
<p>　　锁是在多用户环境中对<strong>数据的访问的限制</strong>。SqlServer自动锁定特定记录、字段或文件，防止用户访问，以维护数据安全或防止并发数据操作问题，锁可以保证事务的完整性和并发性。</p>
<p> <strong>3.什么是索引，有什么优点？</strong></p>
<p>答：索引象书的目录类似，索引使数据库程序无需扫描整个表，就可以在其中找到所需要的数据，索引包含了一个表中包含值的列表，其中包含了各个值的行所存储的位置，索引可以是单个或一组列，索引提供的表中数据的逻辑位置，合理划分索引能够大大<strong>提高数据库性能</strong>。</p>
<p> <strong>4.视图是什么？游标是什么？</strong></p>
<p>答：视图是一种<strong>虚拟表</strong>，虚拟表具有和物理表相同的功能，可以对虚拟表进行增该查操作;</p>
<p>​    视图通常是<strong>一个或多个表的行或列的子集</strong>;</p>
<p>   视图的结果更容易理解（修改视图对基表不影响），获取数据更容易（相比多表查询更方便），限制数据检索（比如需要隐藏某些行或列），维护更方便。</p>
<p>   游标对查询出来的<strong>结果集</strong>作为一个<strong>单元</strong>来有效的处理，游标可以定位在结果集的特定行、从结果集的当前位置检索一行或多行、可以对结果集中当前位置进行修改、</p>
<p> <strong>5.什么是存储过程？有什么优点？</strong></p>
<p>答：存储过程是一组<strong>予编译的SQL语句</strong></p>
<p>​    它的优点：1.允许<strong>模块化程序设计</strong>，就是说只需要创建一次过程，以后在程序中就可以调用该过程任意次。</p>
<p>​          　　  2.允<strong>许更快执行</strong>，如果某操作需要执行大量SQL语句或重复执行，存储过程比SQL语句执行的要快。</p>
<p>​           　   3.<strong>减少网络流量</strong>，例如一个需要数百行的SQL代码的操作有一条执行语句完成，不需要在网络中发送数百行代码。</p>
<p>　　　　　   4.<strong>更好的安全机制</strong>，对于没有权限执行存储过程的用户，也可授权他们执行存储过程。</p>
<p> <strong>6.什么是触发器？</strong></p>
<p>答：触发器是一种<strong>特殊类型的存储过程</strong>，出发器主要通过事件触发而被执行的，</p>
<p>　　触发器的优点：1.<strong>强化约束</strong>，触发器能够提供比CHECK约束;</p>
<p>　　　　　　　　　2.<strong>跟踪变化</strong>，触发器可以跟踪数据库内的操作，从而不允许未经允许许可的更新和变化;</p>
<p>　　　　　　　　　3.<strong>联级运算</strong>，比如某个表上的触发器中包含对另一个表的数据操作，而该操作又导致该表上的触发器被触发</p>
<p> <strong>7.简单介绍下ADO.NET和ADO主要有什么改进？</strong></p>
<p>答：ADO以Recordset存储,而ADO.NET则以<strong>DataSet</strong>表示，ADO.NET提供了<strong>数据集和数据适配器</strong>，有利于实现分布式处理，降低了对数据库服务器资源的消耗。</p>
<p> <strong>7.1 ASP.NET与ASP相比，主要有哪些进步？</strong></p>
<p>答：ASP.NET实现了面向对象编程，<strong>预编译的服务器端代码</strong>而不像ASP那样解释执行提高了性能，代码分离易于管理，可订制和扩展性，功能强大的开发工作，更好的安全机制。</p>
<p> <strong>7.2 C#中的委托是什么？事件是不是一种委托？</strong></p>
<p>答：委托本质上是一种“<strong>方法接口</strong>”，它相当于C/C++中的函数指针，当然它比函数指针安全，在C#中通常用于事件处理。</p>
<p>​     <strong>事件不是委托</strong>，不过由于事件的性质决定了处理它的程序逻辑能访问的参数，因此，在C#中处<strong>理事件的逻辑都包装为委托</strong>。</p>
<p> <strong>8.如何把一个array复制到arrayist里</strong></p>
<p>答：foreach( object arr in array)arrayist.Add(arr);</p>
<p> <strong>8.1 列举ADO.NET中的五个主要对象，并简单描述</strong></p>
<p>答：<strong>Connection</strong>连接对象，<strong>Command</strong>执行命令和存储过程，<strong>DataReader</strong>向前只读的数据流，<strong>DataAdapter</strong>适配器，支持增删查询，<strong>DataSet</strong>数据级对象，相当与内存里的一张或多张表。</p>
<p> <strong>9.概述三层结构体系</strong></p>
<p>答：表示层(UI),业务逻辑层(BLL),数据访问层(DAL)</p>
<p> <strong>10.什么是装箱和拆箱？什么是重载？</strong></p>
<p>答：装箱就是把值类型转成引用类型，拆箱相反把引用转换成值类型。</p>
<p>　　重载就是指一个方法名相同,参数个数不相同,返回值可以相同的方法。</p>
<p><strong>11.简述WebService</strong></p>
<p>答：WebService服务可以描述为可以在web上部署并可以被任何应用程序或其他服务调用的功能。所谓服务就是系统提供一组接口，并通过接口使用系统提供的功能，WebService服务可以提供任何企业到客户，企业到企业，点对点或部门对部门通讯所需的服务，比如一个公司可以通过网络连接到另一个公司的服务，从而直接传递订购单。</p>
<p><strong>12.面向对象的思想主要包括什么？</strong></p>
<p>答：继承、封装、多态</p>
<p><strong>13.列举一下你所了解的XML技术及其应用</strong></p>
<p>答：xml可以用来做网页(xslt)、可以当作数据库、可以用来保存对象的系列化(web服务好象是基于这个的)。xml用于配置,用于保存静态数据类型.接触XML最多的是web Services和config</p>
<p><strong>14.C#中的接口和类有什么异同。</strong></p>
<p>答：接口,是可以多继承,类只有单继承.接口强调了你必须实现,而没有具本实现的方法和虚类有点相似。</p>
<p><strong>15.new 关键字用法</strong></p>
<p>答：(1)new 运算符 用于创建对象和调用构造函数。</p>
<p>​     (2)new 修饰符 用于向基类成员隐藏继承成员。</p>
<p>​     (3)new 约束   用于在泛型声明中约束可能用作类型参数的参数的类型。</p>
<p><strong>14.DataGrid的Datasouse可以连接什么数据源</strong></p>
<p>答：DataTabe，DataView，DataSet，DataViewManager，任何实现IListSource接口的组件，任何实现IList接口的组件</p>
<p><strong>15.概述反射和序列化</strong></p>
<p>答：反射：公共语言运行库加载器管理应用程序域。这种管理包括将每个程序集加载到相应的应用程序域以及控制每个程序集中类型层次结构的内存布局。程序集包含模块，而模块包含类型，类型又包含成员。反射则提供了封装程序集、模块和类型的对象。您可以使用反射动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型。然后，可以调用类型的方法或访问其字段和属性。</p>
<p>　　序列化：序列化是将对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以轻松地存储和传输数据。</p>
<p><strong>16.概述O/R Mapping 的原理</strong></p>
<p>答：利用反射，配置将对象和数据库表映射。</p>
<p> <strong>17.可访问性级别有哪几种</strong></p>
<p>答：pubic 访问不受限制。</p>
<p>　　protected 访问仅限于包含类或从包含类派生的类型。</p>
<p>　　internal 访问仅限于当前程序集。</p>
<p>　　protected internal 访问仅限于从包含类派生的当前程序集或类型。</p>
<p>　　private 访问仅限于包含类型。</p>
<p> <strong>18.sealed修饰符有什么特点</strong></p>
<p>答：sealed 修饰符可以应用于类、实例方法和属性。</p>
<p>​    密封类不能被继承；</p>
<p>　密封方法会重写基类中的方法，但其本身不能在任何派生类中进一步重写。当应用于方法或属性时，sealed 修饰符必须始终与 override一起使用。</p>
<p> <strong>19.列举ADO.NET中的共享类和数据库特定类</strong></p>
<p>答：共享类：DataSet，DataTable，DataRow，DataColumn，DataRealtion，Constraint，DataColumnMapping，DataTableMapping</p>
<p>　　特定类：(x)Connection，(x)Command，(x)CommandBuilder，(x)DataAdapter，(x)DataReader，(x)Parameter，(x)Transaction</p>
<p> <strong>20.C#中，string str = null 与 string str =””，请尽量用文字说明区别</strong></p>
<p>答：string str=””初始化对象分配空间，而stringstr=null初始化对象</p>
<p> <strong>21.详述.NET里class和struct的异同</strong></p>
<p>答：结构与类共享几乎所有相同的语法，但结构比类受到的限制更多：尽管结构的静态字段可以初始化，结构实例字段声明还是不能使用初始值设定项。</p>
<p>　　结构不能声明默认构造函数（没有参数的构造函数）或析构函数。</p>
<p>　　结构的副本由编译器自动创建和销毁，因此不需要使用默认构造函数和析构函数。实际上，编译器通过为所有字段赋予默认值（参见默认值表）来实现默认构造函数。</p>
<p>　　结构不能从类或其他结构继承。</p>
<p>　　结构是值类型 – 如果从结构创建一个对象并将该对象赋给某个变量，变量则包含结构的全部值。复制包含结构的变量时，将复制所有数据，对新副本所做的任何修改都不会改变旧副本的数据。</p>
<p>　　由于结构不使用引用，因此结构没有标识 – 具有相同数据的两个值类型实例是无法区分的。C# 中的所有值类型本质上都继承自ValueType，后者继承自 Object。编译器可以在一个称为装箱的过程中将值类型转换为引用类型。</p>
<p>结构具有以下特点：</p>
<p>　　结构是值类型，而类是引用类型。</p>
<p>　　向方法传递结构时，结构是通过传值方式传递的，而不是作为引用传递的。</p>
<p>　　与类不同，结构的实例化可以不使用 new 运算符。</p>
<p>　　结构可以声明构造函数，但它们必须带参数。</p>
<p>　　一个结构不能从另一个结构或类继承，而且不能作为一个类的基。所有结构都直接继承自 System.ValueType，后者继承自 System.Object。</p>
<p>　　结构可以实现接口。</p>
<p>　　在结构中初始化实例字段是错误的。</p>
<p> <strong>22.什么叫应用程序域？什么是托管代码？什么是强类型系统？什么是装箱和拆箱？什么是重载？ CTS、CLS和CLR分别作何解释？</strong></p>
<p>答：应用程序域：应用程序域为安全性、可靠性、版本控制以及卸载程序集提供了隔离边界。应用程序域通常由运行库宿主创建，运行库宿主负责在运行应用程序之前引导公共语言运行库。应用程序域提供了一个更安全、用途更广的处理单元，公共语言运行库可使用该单元提供应用程序之间的隔离。</p>
<p>　　托管代码：使用基于公共语言运行库的语言编译器开发的代码称为托管代码；托管代码具有许多优点，例如：跨语言集成、跨语言异常处理、增强的安全性、版本控制和部署支持、简化的组件交互模型、调试和分析服务等。</p>
<p>　　强类型：C# 是强类型语言；因此每个变量和对象都必须具有声明类型。</p>
<p>　　装箱和拆箱：装箱和拆箱使值类型能够被视为对象。对值类型装箱将把该值类型打包到 Object 引用类型的一个实例中。这使得值类型可以存储于垃圾回收堆中。拆箱将从对象中提取值类型。</p>
<p>　　重载：每个类型成员都有一个唯一的签名。方法签名由方法名称和一个参数列表（方法的参数的顺序和类型）组成。只要签名不同，就可以在一种类型内定义具有相同名称的多种方法。当定义两种或多种具有相同名称的方法时，就称作重载。</p>
<p>　　CTS通用类型系统 (common type system) ：一种确定公共语言运行库如何定义、使用和管理类型的规范。</p>
<p>　　CLR公共语言运行库：.NET Framework 提供了一个称为公共语言运行库的运行时环境，它运行代码并提供使开发过程更轻松的服务。</p>
<p>　　CLS公共语言规范：要和其他对象完全交互，而不管这些对象是以何种语言实现的，对象必须只向调用方公开那些它们必须与之互用的所有语言的通用功能。为此定义了公共语言规范 (CLS)，它是许多应用程序所需的一套基本语言功能。</p>
<p><strong>23.值类型和引用类型的区别？</strong></p>
<p>答：基于值类型的变量直接包含值。将一个值类型变量赋给另一个值类型变量时，将复制包含的值。这与引用类型变量的赋值不同，引用类型变量的赋值只复制对对象的引用，而不复制对象本身。</p>
<p>　　所有的值类型均隐式派生自 System.ValueType。与引用类型不同，从值类型不可能派生出新的类型。但与引用类型相同的是，结构也可以实现接口。</p>
<p>　　与引用类型不同，值类型不可能包含 null 值。然而，可空类型功能允许将null 赋给值类型。 每种值类型均有一个隐式的默认构造函数来初始化该类型的默认值。</p>
<p>　　值类型主要由两类组成：结构、枚举； 结构分为以下几类：Numeric（数值）类型、整型、浮点型、decimal、bool、用户定义的结构。</p>
<p>　　引用类型的变量又称为对象，可存储对实际数据的引用。声明引用类型的关键字：class、interface、delegate、内置引用类型： object、string</p>
<p><strong>24.如何理解委托</strong></p>
<p>答：委托类似于 C++ 函数指针，但它是类型安全的。委托允许将方法作为参数进行传递。委托可用于定义回调方法。委托可以链接在一起；例如，可以对一个事件调用多个方法。方法不需要与委托签名精确匹配。有关更多信息，请参见协变和逆变。C# 2.0 版引入了匿名方法的概念，此类方法允许将代码块作为参数传递，以代替单独定义的方法。</p>
<p><strong>25.C#中的接口和类有什么异同？</strong></p>
<p>答：异：接口不能直接实例化。</p>
<p>　　　　接口不包含方法的实现。</p>
<p>　　　　接口、类和结构可从多个接口继承。但是C#类只支持单继承：类只能从一个基类继承实现。类定义可在不同的源文件之间进行拆分。</p>
<p>　　同：接口、类和结构可从多个接口继承。</p>
<p>　　　　接口类似于抽象基类：继承接口的任何非抽象类型都必须实现接口的所有成员。</p>
<p>　　　　接口可以包含事件、索引器、方法和属性。</p>
<p><strong>26.ASP.net的身份验证方式有哪些？</strong></p>
<p>答：Windows 身份验证提供程序：提供有关如何将Windows 身份验证与Microsoft Internet 信息服务 (IIS) 身份验证结合使用来确保 ASP.NET 应用程序安全的信息。</p>
<p>　　Forms 身份验证提供程序：提供有关如何使用您自己的代码创建应用程序特定的登录窗体并执行身份验证的信息。使用 Forms 身份验证的一种简便方法是使用 ASP.NET 成员资格和 ASP.NET 登录控件，它们一起提供了一种只需少量或无需代码就可以收集、验证和管理用户凭据的方法。</p>
<p>　　Passport 身份验证提供程序：提供有关由Microsoft 提供的集中身份验证服务的信息，该服务为成员站点提供单一登录和核心配置</p>
<p><strong>27.活动目录的作用</strong></p>
<p>答：Active Directory存储了有关网络对象的信息，并且让管理员和用户能够轻松地查找和使用这些信息。</p>
<p>　　Active Directory使用了一种结构化的数据存储方式，并以此作为基础对目录信息进行合乎逻辑的分层组织。</p>
<p> <strong>28.解释一下UDDI、WSDL的意义及其作用</strong></p>
<p>答：UDDI：统一描述、发现和集成协议(UDDI, Universa Description, Discovery and Integration)是一套基于Web的、分布式的、为Web服务提供的信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的Web服务注册以使得别的企业能够发现的访问协议的实现标准。UDDI 提供了一组基于标准的规范用于描述和发现服务，还提供了一组基于因特网的实现。</p>
<p>　　WSDL：WSDL描述Web服务的公共接口。这是一个基于XML的关于如何与Web服务通讯和使用的服务描述；</p>
<p>　　作用： 服务 URL 和命名空间 ：网络服务的类型（可能还包括SOAP 的函数调用，正像我所说过的，WSDL足够自如地去描述网络服务的广泛内容）。有效函数列表，每个函数的参数，每个参数的类型 ，每个函数的返回值及其数据类型。</p>
<p> <strong>29.什么是SOAP？</strong></p>
<p>答：SOAP（Simpe Object Access Protoco ）简单对象访问协议是在分散或分布式的环境中交换信息并执行远程过程调用的协议，是一个基于XML的协议。使用SOAP，不用考虑任何特定的传输协议（最常用的还是HTTP协议），可以允许任何类型的对象或代码，在任何平台上，以任何一直语言相互通信。</p>
<p>　　SOAP 是一种轻量级协议，用于在分散型、分布式环境中交换结构化信息。 SOAP 利用 XML 技术定义一种可扩展的消息处理框架，它提供了一种可通过多种底层协议进行交换的消息结构。这种框架的设计思想是要独立于任何一种特定的编程模型和其他特定实现的语义。</p>
<p>　　SOAP 定义了一种方法以便将 XML 消息从 A 点传送到 B 点。为此，它提供了一种基于 XML且具有以下特性的消息处理框架：1) 可扩展，2) 可通过多种底层网络协议使用，3) 独立于编程模型。</p>
<p> <strong>30.如何部署一个ASP.net页面？</strong></p>
<p>答：VS 2005和VS 2003都有发布机制。2003可以发布然后再复制部署。VS2005基本上可以直接部署到对应位置。</p>
<p> <strong>31.如何理解.net中的垃圾回收机制？</strong></p>
<p>答：.NETFramework 的垃圾回收器管理应用程序的内存分配和释放。每次您使用 new 运算符创建对象时，运行库都从托管堆为该对象分配内存。只要托管堆中有地址空间可用，运行库就会继续为新对象分配空间。但是，内存不是无限大的。最终，垃圾回收器必须执行回收以释放一些内存。垃圾回收器优化引擎根据正在进行的分配情况确定执行回收的最佳时间。当垃圾回收器执行回收时，它检查托管堆中不再被应用程序使用的对象并执行必要的操作来回收它们占用的内存。</p>
<p> <strong>32.概述.NET中的GC机制。</strong></p>
<p>答：GC的全称是garbage collection，中文名称垃圾回收，是.NET中对内存管理的一种功能。垃圾回收器跟踪并回收托管内存中分配的对象，定期执行垃圾回收以回收分配给没有有效引用的对象的内存。当使用可用内存不能满足内存请求时，GC会自动进行。</p>
<p>　　在进行垃圾回收时，垃圾回收器会首先搜索内存中的托管对象，然后从托管代码中搜索被引用的对象并标记为有效，接着释放没有被标记为有效的对象并收回内存，最后整理内存将有效对象挪动到一起</p>
<p><strong>33.GC是什么? 为什么要有GC?</strong><br>答：GC是垃圾收集器。程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：<br>System.gc()<br>Runtime.getRuntime().gc()</p>
<p> <strong>33.ASP.NET中常见内置对象？</strong></p>
<p>答：Response、Request、Server、Session、Application、Cookie</p>
<p> <strong>34.死锁的必要条件？怎么克服？</strong></p>
<p>答：系统的资源不足，进程的推进的顺序不合适，资源分配不当，一个资源每次只能被一个进程使用，一个资源请求资源时，而此时这个资源已阻塞，对已获得资源不放，进程获得资源时，未使用完前，不能强行剥夺。</p>
<p><strong>35.接口是否可以继承接口？抽象类是否可以实现接口？抽象类是否可以继承实体类？</strong></p>
<p>答：接口是可以继承接口的，抽象类是可以实现接口的，抽象类可以继承实体类，但是有个条件，条件是，实体类必须要有明确的构造函数。</p>
<p> <strong>36.构造器Constructor是否可以被继承？是否可以被Override?</strong></p>
<p>答：Constructor不可以被继承，因此不能被重写（Overriding），但可以被重载(Overloading).</p>
<p><strong>37.是否可以继承String类？</strong></p>
<p>答：因为String类是final类所以不可以继承string类。</p>
<p><strong>38.当一个线程进入一个对象的方法后，其它线程是否可以进入该对象的方法？</strong></p>
<p>答：不可以，一个对象的方法只能由一个线程访问。</p>
<p> <strong>39.用最有效的方法算出2乘以8等于几？</strong></p>
<p>答：2&lt;&lt;3.</p>
<p><strong>40.C#是否可以对内存直接进行操作？</strong></p>
<p>答：C#是可以对内存进行直接操作的，虽然很少用到指针，但是C#是可以使用指针的，在用的时候需要在前边加unsafe,，在.net中使用了垃圾回收机制（GC）功能，它替代了程序员，不过在C#中不可以直接使用finalize方法，而是在析构函数中调用基类的finalize()方法。</p>
<p><strong>41.数组有没有Length()这和方法？string有没有这个方法？</strong></p>
<p>答：数组中没有这个方法，但有这个属性，string中有这个方法。</p>
<p><strong>42.Error和Exception有是区别？</strong></p>
<p>答：error表示恢复不是不可能，但是很困难，exception表示一种实际或实现问题，它表示程序运行正常不可以发生的。</p>
<p><strong>43.HashMap和Hashtable区别？</strong></p>
<p>答：HashMap是Hashtable的轻量级实现，非线程安全的实现他们都实现了map接口，主要区别是HashMap键值可以为空null,效率可以高于Hashtable。</p>
<p><strong>44.Collection和Collections的区别？</strong></p>
<p>答：Collection是集合类的上级接口，Collections是针对集合类的一个帮助类，它提供一系列静态方法来实现对各种集合的搜索，排序，线程安全化操作。</p>
<p><strong>45.Override, Overload,的区别？</strong></p>
<p>答：Override是重写的意思，它表示重写基类的方法，而且方法的名称，返回类型，参数类型，参数个数要与基类相同。</p>
<p>　　Overload是重载是意思，它也表示重写基类的方法，但是只要方法名相同，别的可以不同。</p>
<p><strong>46.在一个BS结构中需要传递变量值时，不能使用session,cookie,application,你有几中方法？</strong></p>
<p>答：this.server.Transfer,Querystring.</p>
<p><strong>47.C#种索引器实现过程，是否只能根据数字索引？</strong></p>
<p>答：不是的，可以是任意类型。</p>
<p><strong>48.Const和ReadOnly？</strong></p>
<p>答：Const用来申明编程时申明常量，ReadOnly用来申明运行时常量。</p>
<p> <strong>49.UDP和TCP连接有和异同？</strong></p>
<p>答：TCP是传输控制协议，提供的是面向连接的，是可靠的，字节流服务，当用户和服务器彼此进行数据交互的时候，必须在他们数据交互前要进行TCP连接之后才能传输数据。TCP提供超时重拨，检验数据功能。</p>
<p>　 UDP是用户数据报协议，是一个简单的面向数据报的传输协议，是不可靠的连接。</p>
<p><strong>50.进程和线程分别该怎么理解？</strong></p>
<p>答：进程是比线程大的程序运行单元，都是由操作系统所体会的系统运行单元</p>
<p>​    一个程序中至少要有一个进程，一个进程中，至少要有一个线程，线程的划分尺度要比进程要小，进程拥有独立的内存单元，线程是共享内存，从而极大的提高了程序的运行效率同一个进程中的多个线程可以并发执行。</p>
<p> <strong>51.在.NET中所有类的基类是？</strong></p>
<p>答：object。</p>
<p> <strong>52.能用foreach遍历访问的对象需要实现？</strong></p>
<p>答：需要实现IEnumerable接口和GetEnumerator()方法。</p>
<p> <strong>53.Heap与stack的差别？</strong></p>
<p>答：Heap是堆，空间是由手动操作分配和释放的，它的存储区很大的自由存储区。</p>
<p>　　Stack是栈，是由是操作系统自动分配和释放的，栈上的空间是有限的。程序在编译期间变量和函数分配内存都是在栈上进行的，且在运行时函数调用时的参数的传递也是在栈上进行的。</p>
<p> <strong>54.请编程遍历页面上所有TextBox控件并给它赋值为string.Empty？</strong></p>
<p>答：foreach(System.Windows.Forms.Control control in this.Controls)</p>
<p>　　{</p>
<p>　　　　if (control is  System.Windows.Forms.TextBox)</p>
<p>　　　　{</p>
<p>　　　　　　System.Windows.Forms.TextBox tb =(System.Windows.Forms.TextBox)control ;</p>
<p>　　　　　　 tb.Text = String.Empty ;</p>
<p>　　　　}</p>
<p>　　}</p>
<p><strong>55.请编程实现一个冒泡排序算法？</strong></p>
<p>答：int [] array= new int [*] ;</p>
<p>　　int temp = 0 ;</p>
<p>　　for (int i = 0 ; i &lt; array.Length - 1 ;i++)</p>
<p>　　{</p>
<p>　　　　for (int j = i + 1 ; j &lt; array.Length ;j++)</p>
<p>　　　　{</p>
<p>　　　　　　if (array[j] &lt; array[i])</p>
<p>　　　　　　{</p>
<p>　　　　　　　　temp = array[i] ;</p>
<p>　　　　　　　　array[i] = array[j] ;</p>
<p>　　　　　　　　array[j] = temp ;</p>
<p>　　　　　　}</p>
<p>　　　　}</p>
<p>　　}</p>
<p><strong>56.求以下表达式的值，写出您想到的一种或几种实现方法： 1-2+3-4+……+m</strong></p>
<p>答：int Num =this.TextBox1.Text.ToString() ;</p>
<p>　　int Sum = 0 ;</p>
<p>　　for (int i = 0 ; i &lt; Num + 1 ; i++)</p>
<p>　　{</p>
<p>　　　　if((i%2) == 1)</p>
<p>　　　　{</p>
<p>　　　　　　Sum += i ;</p>
<p>　　　　}</p>
<p>　　　　else</p>
<p>　　　　{</p>
<p>　　　　　　Sum = Sum - i ;</p>
<p>　　　　}</p>
<p>　　}</p>
<p>　　Console.WriteLine(Sum.ToString());</p>
<p>　　Console.ReadLine() ;</p>
<p><strong>58.什么是受管制的代码？</strong></p>
<p>答：unsafe：非托管代码。不经过CLR运行。</p>
<p><strong>59.在.net中，配件的意思是？</strong></p>
<p>答：程序集。（中间语言，源数据，资源，装配清单）</p>
<p><strong>60.常用的调用WebService的方法有哪些？</strong></p>
<p>答：1.使用WSDL.exe命令行工具。</p>
<p>​    2.使用VS.NET中的Add Web Reference菜单选项</p>
<p><strong>61. .net Remoting 的工作原理是什么？</strong></p>
<p>答：服务器端向客户端发送一个进程编号，一个程序域编号，以确定对象的位置。</p>
<p><strong>62.根据线程安全的相关知识，分析以下代码，当调用test方法时i&gt;10时是否会引起死锁?并简要说明理由。</strong></p>
<p>public void test(int i)</p>
<p>{</p>
<p>　　lock(this)</p>
<p>　　{</p>
<p>　　　　if (i&gt;10)</p>
<p>　　　　{</p>
<p>　　　　　　i–;</p>
<p>　　　　　　test(i);</p>
<p>　　　　}</p>
<p>　　}</p>
<p>}</p>
<p>答：不会发生死锁，（但有一点int是按值传递的，所以每次改变的都只是一个副本，因此不会出现死锁。但如果把int换做一个object，那么死锁会发生）</p>
<p> <strong>63.简要谈您对微软.NET 构架下remoting和webservice两项技术的理解以及实际中的应用。</strong></p>
<p>答：WS主要是可利用HTTP，穿透防火墙。而Remoting可以利用TCP/IP，二进制传送提高效率。</p>
<p>　　remoting是.net中用来跨越machine,process, appdomain进行方法调用的技术,对于三层结构的程序，就可以使用remoting技术来构建．它是分布应用的基础技术.相当于以前的DCOM。</p>
<p>　　Web Service是一种构建应用程序的普通模型，并能在所有支持internet网通讯的操作系统上实施。Web Service令基于组件的开发和web的结合达到最佳，基于组件的对象模型。</p>
<p> <strong>64.公司要求开发一个继承System.Windows.Forms.ListView类的组件，要求达到以下的特殊功能：点击ListView各列列头时，能按照点击列的每行值进行重排视图中的所有行 (排序的方式如DataGrid相似)。根据您的知识，请简要谈一下您的思路</strong></p>
<p>答：根据点击的列头,包该列的ID取出,按照该ID排序后,在给绑定到ListView中。</p>
<p><strong>65.给定以下XML文件，完成算法流程图。</strong></p>
<filesystem>

<p>　　&lt; DriverC &gt;</p>
<p>　　　　<dir dirname="”MSDOS622”"></dir></p>
<p>　　　　　　&lt;File FileName =” Command.com”&gt;</p>
<p>　　　　</p>
<p>　　　　<file filename="”MSDOS.SYS”"></file></p>
<p>　　　　&lt;File FileName =” IO.SYS”&gt;</p>
<p>　　</p>
</filesystem>

<p><strong>请画出遍历所有文件名（FileName）的流程图(请使用递归算法)。</strong></p>
<p>答：voidFindFile( Directory d )</p>
<p>　  {</p>
<p>　　　　FileOrFolders = d.GetFileOrFolders();</p>
<p>　　　　foreach( FileOrFolder fof in FileOrFolders)</p>
<p>　　　　{</p>
<p>　　　　　　if(fof  is  File)</p>
<p>　　　　　　　　You Found a file;</p>
<p>　　　　　　else if (fof is Directory)</p>
<p>　　　　　　　　FindFile( fof );</p>
<p>}</p>
<p>}</p>
<p>方法二</p>
<p>  Public void DomDepthFirst(XmlNode currentNode)<br>{<br>    XmlNode node=currentNode.FirstChild;<br>    while(node!=null)<br>    {</p>
<p>​        if(node.Name==”File”)<br>​        {<br>​              Console.Write(((XmlElement)node).GetAttribute(“FileName”)+”\r\n”);<br>​         }</p>
<p>​          DomDepthFirst(node);<br>​          node=node.NextSibling;<br>​    }</p>
<p>}</p>
<p> <strong>66.String s = new String(“xyz”);创建了几个String Object?</strong></p>
<p>答：两个对象，一个是“xyx”,一个是指向“xyx”的引用对像s。</p>
<p> <strong>67.abstract class和interface有什么区别?</strong></p>
<p>答：声明方法的存在而不去实现它的类被叫做抽像类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽像类，并让它指向具体子类的一个实例。不能有抽像构造函数或抽像静态方法。Abstract 类的子类为它们父类中的所有抽像方法提供实现，否则它们也是抽像类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。</p>
<p>　　接口（interface）是抽像类的变体。在接口中，所有方法都是抽像的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽像的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对像上调用接口的方法。由于有抽像类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。</p>
<p> <strong>68.启动一个线程是用run()还是start()?</strong></p>
<p>答：启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。</p>
<p>　　run()方法可以产生必须退出的标志来停止一个线程。</p>
<p><strong>69.两个对像值相同(x.equals(y)== true)，但却可有不同的hashcode，这句话对不对?</strong></p>
<p>答：不对，有相同的hashcode。</p>
<p> <strong>70.swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上?</strong></p>
<p>答：switch（expr1）中，expr1可以是一个整型，字符或字符串，因此可以作用在byte和long上，也可以作用在string上。</p>
<p> <strong>71.当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?</strong></p>
<p>答：不能，一个对象的一个synchronized方法只能由一个线程访问。</p>
<p> <strong>72.abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized?</strong></p>
<p>答：都不能。</p>
<p> <strong>73.List, Set, Map是否继承自Collection接口?</strong></p>
<p>答：List，Set是，Map不是</p>
<p><strong>74.Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别?</strong></p>
<p>答：Set里的元素是不能重复的，那么用iterator()方法来区分重复与否。equals()是判读两个Set是否相等。</p>
<p>　　equals()和==方法决定引用值是否指向同一对像，equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。</p>
<p><strong>75.sleep() 和 wait() 有什么区别?</strong></p>
<p>答：sleep()方法是将当前线程挂起指定的时间。</p>
<p>　　wait()释放对象上的锁并阻塞当前线程，直到它重新获取该锁。</p>
<p><strong>76.short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?</strong></p>
<p>答：short s1 =1; s1 = s1 + 1;有错，</p>
<p>　　s1是short型，s1+1是int型,不能显式转化为short型。可修改为s1=(short)(s1 + 1) 。short s1 = 1;s1 += 1正确。</p>
<p><strong>77.谈谈final,finally, finalize的区别。</strong></p>
<p>答：final－修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中 不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为 final的方法也同样只能使用，不能重载</p>
<p>　　finally－再异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。</p>
<p>　　finalize－方法名。Java 技术允许使用finalize() 方法在垃圾收集器将对像从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的 ，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对像之前对这个对象调用的。</p>
<p> <strong>78.如何处理几十万条并发数据？</strong></p>
<p>答：用存储过程或事务。取得最大标识的时候同时更新。注意主键不是自增量方式，这种方法并发的时候是不会有重复主键的。取得最大标识要有一个存储过程来获取.</p>
<p> <strong>79.Session有什么重大BUG，微软提出了什么方法加以解决？</strong></p>
<p>答：是iis中由于有进程回收机制，系统繁忙的话Session会丢失，可以用Sate server或SQL Server数据库的方式存储Session不过这种方式比较慢，而且无法捕获Session的END事件。</p>
<p> <strong>80.成员变量和成员函数前加static的作用？</strong></p>
<p>答：它们被称为常成员变量和常成员函数，又被称为类成员变量和类成员函数。分别用来反映类的状态。比如类成员变量可以用来统计类实例的数量，类成员函数负责这种统计的动作。</p>
<p><strong>81.请说明在.net中常用的几种页面间传递参数的方法，并说出他们的优缺点。</strong></p>
<p>答：session(viewstate)简单，但易丢失</p>
<p>　　application 全局</p>
<p>　　cookie 简单，但可能不支持，可能被伪造</p>
<p>　　input type=”hidden” 简单，可能被伪造</p>
<p>　　url参数简单，显示于地址栏，长度有限</p>
<p>　　数据库稳定，安全，但性能相对弱</p>
<p><strong>82.请指出GAC的含义？</strong></p>
<p>答：全局程序集缓存。</p>
<p> <strong>83.向服务器发送请求有几种方式？</strong></p>
<p>答：get,post。get一般为链接方式，post一般为按钮方式。</p>
<p> <strong>84.软件开发过程一般有几个阶段？每个阶段的作用？</strong></p>
<p>答：需求分析，架构设计，代码编写，QA，部署</p>
<p> <strong>85.在c#中using和new这两个关键字有什么意义，请写出你所知道的意义？using 指令 和语句 new 创建实例 new 隐藏基类中方法。</strong></p>
<p>答：using 引入名称空间或者使用非托管资源</p>
<p>　　new 新建实例或者隐藏父类方法</p>
<p><strong>86.需要实现对一个字符串的处理,首先将该字符串首尾的空格去掉,如果字符串中间还有连续空格的话,仅保留一个空格,即允许字符串中间有多个空格,但连续的空格数不可超过一个.</strong></p>
<p>答：string inputStr=” xx xx “;</p>
<p>　　inputStr = Regex.Replace(inputStr.Trim(),”*”,” “);</p>
<p><strong>87.什么叫做SQL注入，如何防止？请举例说明。</strong></p>
<p>答：利用sql语言漏洞获得合法身份登陆系统。如身份验证的程序设计成：</p>
<p>　　SqlCommand com=new SqlCommand(“Select * from users where username=’”+t_name.text+”‘ and pwd=’”+t_pwd.text+”‘“);</p>
<p>　　object obj=com.ExcuteScale();</p>
<p>　　if(obj!=null)</p>
<p>​    {</p>
<p>​      //通过验证</p>
<p>​    }</p>
<p>　　这段代码容易被sql注入。如用户在t_name中随便输入，在t_pwd中输入1’ and 1=’1  就可以进入系统了。</p>
<p> <strong>88.什么是ApplicationPool？</strong></p>
<p>答：Web应用，类似Thread Pool，提高并发性能。</p>
<p>89<strong>.什么是XML？</strong></p>
<p>答：XML即可扩展标记语言。eXtensible Markup Language.标记是指计算机所能理解的信息符号，通过此种标记，计算机之间可以处理包含各种信息的文章等。如何定义这些标记，即可以选择国际通用的标记语言，比如HTML，也可以使用象XML这样由相关人士自由决定的标记语言，这就是语言的可扩展性。XML是从SGML中简化修改出来的。它主要用到的有XML、XSL和XPath等。</p>
<p> <strong>90.什么是ASP.net中的用户控件？</strong></p>
<p>答：用户控件一般用在内容多为静态,或者少许会改变的情况下.用的比较大.类似ASP中的include.但是功能要强大的多。</p>
<p><strong>91.什么是code-Behind技术。</strong></p>
<p>答：aspx,resx和cs三个后缀的文件，这个就是代码分离.实现了HTML代码和服务器代码分离.方便代码编写和整理.</p>
<p><strong>92.XML 与 HTML 的主要区别</strong></p>
<p>答：1. XML是区分大小写字母的，HTML不区分。</p>
<p>　　2. 在HTML中，如果上下文清楚地显示出段落或者列表键在何处结尾，那么你可以省略</p>或者之类的结束 标记。在XML中，绝对不能省略掉结束标记。<p></p>
<p>　　3. 在XML中，拥有单个标记而没有匹配的结束标记的元素必须用一个 / 字符作为结尾。这样分析器就知道不用查找结束标记了。</p>
<p>　　4. 在XML中，属性值必须分装在引号中。在HTML中，引号是可用可不用的。</p>
<p>　　5. 在HTML中，可以拥有不带值的属性名。在XML中，所有的属性都必须带有相应的值。</p>
<p><strong>93.类成员有_____种可访问形式？</strong></p>
<p>答：this.; newClass().Method;</p>
<p> <strong>94.在Asp.net中所有的自定义用户控件都必须继承自<strong>____</strong>?</strong></p>
<p>答：Control。</p>
<p>95<strong>.在.Net中所有可序列化的类都被标记为_____?</strong></p>
<p>答：[serializable]</p>
<p><strong>96.在.Net托管代码中我们不用担心内存漏洞，这是因为有了<strong>__</strong>?</strong></p>
<p>答：GC</p>
<p>97<strong>.在.Net中，类System.Web.UI.Page 可以被继承么？</strong></p>
<p>答：可以。</p>
<p><strong>98.net的错误处理机制是什么？</strong></p>
<p>答：.net错误处理机制采用try-&gt;catch-&gt;finally结构，发生错误时，层层上抛，直到找到匹配的Catch为止。</p>
<p>99<strong>.利用operator声明且仅声明了==，有什么错误么?</strong></p>
<p>答：要同时修改Equale和GetHash() ? 重载了”==” 就必须重载 “!=”</p>
<p><strong>100.某一密码仅使用K、L、M、N、O共5个字母，密码中的单词从左向右排列，密码单词必须遵循如下规则：</strong></p>
<p>（1） 密码单词的最小长度是两个字母，可以相同，也可以不同</p>
<p>（2） K不可能是单词的第一个字母</p>
<p>（3） 如果L出现，则出现次数不止一次</p>
<p>（4） M不能使最后一个也不能是倒数第二个字母</p>
<p>（5） K出现，则N就一定出现</p>
<p>（6） O如果是最后一个字母，则L一定出现</p>
<p><strong>问题一：下列哪一个字母可以放在LO中的O后面，形成一个3个字母的密码单词？</strong></p>
<p><strong>A) K B)L C) M D) N</strong></p>
<p>答案:B</p>
<p><strong>问题二：如果能得到的字母是K、L、M，那么能够形成的两个字母长的密码单词的总数是多少？</strong></p>
<p><strong>A)1个 B)3个 C)6个 D）9个</strong></p>
<p>答案:A</p>
<p><strong>问题三：下列哪一个是单词密码？</strong></p>
<p><strong>A) KLLN B) LOML C) MLLO D)NMKO</strong></p>
<p>答案:C</p>
<p><strong>109.ADO.NET相对于ADO等主要有什么改进？</strong></p>
<p>答：1:ado.net不依赖于ole db提供程序,而是使用.net托管提供的程序,</p>
<p>　　2:不使用com</p>
<p>　　3:不在支持动态游标和服务器端游</p>
<p>　　4:,可以断开connection而保留当前数据集可用</p>
<p>　　5:强类型转换</p>
<p>　　6:xml支持</p>
<p><strong>110.大概描述一下ASP.NET服务器控件的生命周期</strong></p>
<p>答：初始化 加载视图状态处理回发数据 加载 发送回发更改通知 处理回发事件 预呈现 保存状态 呈现 处置 卸载</p>
<p><strong>111.Anonymous Inner Class (匿名内部类) 是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)?</strong></p>
<p>答：不能，可以实现接口</p>
<p><strong>112.Static Nested Class 和 Inner Class的不同，说得越多越好</strong></p>
<p>答：StaticNested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。</p>
<p><strong>113.&amp;和&amp;&amp;的区别</strong></p>
<p>答：&amp;是位运算符，表示按位与运算，&amp;&amp;是逻辑运算符，表示逻辑与（and）.</p>
<p><strong>114.&lt;%# %&gt; 和 &lt;% %&gt; 有什么区别？</strong></p>
<p>答：&lt;%# %&gt;表示绑定的数据源，&lt;% %&gt;是服务器端代码块</p>
<p><strong>115.你觉得ASP.NET 2.0（VS2005）和你以前使用的开发工具（.Net 1.0或其他）有什么最大的区别？你在以前的平台上使用的哪些开发思想（pattern/ architecture）可以移植到ASP.NET2.0上 (或者已经内嵌在ASP.NET 2.0中)</strong></p>
<p>答：1、ASP.NET2.0把一些代码进行了封装打包,所以相比1.0相同功能减少了很多代码。</p>
<p>　　2、同时支持代码分离和页面嵌入服务器端代码两种模式,以前1.0版本,.NET提示帮助只有在分离的代码文件,无 法 在页面嵌入服务器端代码获得帮助提示。</p>
<p>　　3、代码和设计界面切换的时候,2.0支持光标定位.这个我比较喜欢。</p>
<p>　　4、在绑定数据,做表的分页.UPDATE,DELETE,等操作都可以可视化操作,方便了初学者。</p>
<p>　　5、在ASP.NET中增加了40多个新的控件,减少了工作量。</p>
<p><strong>116.重载与覆盖的区别？</strong></p>
<p>答：1、方法的覆盖是子类和父类之间的关系，是垂直关系；方法的重载是同一个类中方法之间的关系，是水平关系。</p>
<p>　　2、覆盖只能由一个方法，或只能由一对方法产生关系；方法的重载是多个方法之间的关系。</p>
<p>　　3、覆盖要求参数列表相同；重载要求参数列表不同。</p>
<p>　　4、覆盖关系中，调用那个方法体，是根据对象的类型（对像对应存储空间类型）来决定；重载关系，是根据调用时的实参表与形参表来选择方法体的。</p>
<p><strong>117.什么是WSE？目前最新的版本是多少？</strong></p>
<p>答：WSE (WebService Extension)包来提供最新的WEB服务安全保证，最新版本2.0。</p>
<p><strong>118.a=10,b=15，在不用第三方变量的前提下，把a,b的值互换</strong></p>
<p>答：a=a+b;b=a-b;a=a-b;</p>
<p><strong>119.还有变态要求，需要代码最短呢。有两个结果：</strong></p>
<p>1) a^=b^(b^=a^b); // 13个字节</p>
<p>2) a=b+(b=a)*0; // 11个字节</p>
<p><strong>120.请简述面向对象的多态的特性及意义！</strong></p>
<p>答：面向对象的编程使用了派生继承以及虚函数机制.一个本来指向基类的对象指针可以指向其派生类的.并访问从基类继承而来的成员变量和函数.而虚函数是专门为这个特性设计的,这个函数在每个基类的派生类中都是同一个名字,但函数体却并不一定相同,派生类往往为实现自己的功能而修改这个虚函数.这样用一个指针就能够实现对多种不同的派生类的访问, 并实现其派生类的特定功能(代码 )</p>
<p><strong>121.session喜欢丢值且占内存，Cookis不安全，请问用什么办法代替这两种原始的方法</strong></p>
<p>答：用ViewState，stateserver</p>
<p><strong>122.对数据的并发采用什么办法进行处理较好。</strong></p>
<p>答：可以控制连接池的连接数量,条件好的话可以用负载平衡</p>
<p><strong>123.ADO.NET处理数据并发的方法和步骤?</strong></p>
<p>答：开放式并发，没有用到数据库的锁，而依靠SQL语句判断数据是否已经变化了。</p>
<p>​    步骤：通常使用VS提供的工具生成SQL语句，工具生成的结果实在不符合要求，才手工写SQL语句。</p>
<p><strong>124.动态创建的控件PostBack后是否可以保存下来,为什么?</strong></p>
<p>答：ASP.NET框架不会为你保存，但可以手工保存到ViewState</p>
<p> <strong>125.T-SQL中is null和null 的区别?</strong></p>
<p>答：is null 和 null 区别相当于 “是空盒子” 和 “空盒子”的区别</p>
<p><strong>126.什么是值类型?什么是引用类型？</strong></p>
<p>答：值类型：值类型变量声明后，不管是否已经赋值，编译器为其分配内存</p>
<p>例如：byte，short，int，long，float，double，decimal，char，bool 和 struct  </p>
<p>引用类型：当声明一个类时，只在栈中分配一小片内存用于容纳一个地址，而此时<strong>并没有为其分配堆上的内存空间</strong></p>
<p>例如：string 和 class统称为引用类型</p>
<p><strong>127.C#:string、stringBuffer、stringBuilder的区别</strong></p>
<p>答：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string s = &quot;3&quot;;</span><br><span class="line">StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">stringBuilder.Append(&quot;qwe&quot;);</span><br></pre></td></tr></table></figure>

<p>string 是字符串常量，创建之后内存大小固定,对象是不可改变，如果使用s+=”2”;此时s又会开辟新的内存空间</p>
<p>stringBuilder 是字符串变量（非线程安全），<strong>对象是动态对象</strong>，new了一个对象后，实例化后的对象内存大小可以自由变换，也可以这样理解，当我们的向对象中添加的内容超过当前存储的量之前，将自动分配新的空间且容量翻倍。可以使用重载的构造函数之一来指定 StringBuilder 类的容量。 </p>
<p>stringBuffer 是字符串变量（线程安全）</p>
<p><u>stringbuffer和stringbuilder是一样的，后者速度比前者快，但是后者是线程不安全的，前者是线程安全的。</u></p>
<p><strong>128.什么是前后端分离，有什么好处？</strong></p>
<p>答：</p>
]]></content>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>HexoUse</title>
    <url>/2019/10/14/HexoUse/</url>
    <content><![CDATA[<p>1.上传图片显示图片</p>
<p><img src="/2019/10/14/HexoUse/1571020146223.png" alt></p>
<p>需要把图片复制到当前文件夹,还得把<strong>\</strong>改为<strong>/</strong></p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣-数据库3</title>
    <url>/2019/10/13/%E5%8A%9B%E6%89%A3-%E6%95%B0%E6%8D%AE%E5%BA%933/</url>
    <content><![CDATA[<p>编写一个 SQL 查询，获取 <code>Employee</code> 表中第二高的薪水（Salary） 。</p>
<p><img src="/2019/10/13/力扣-数据库3/1570980125556.png" alt></p>
<p>Mysql写法：</p>
<!--首先可能结果为空，Limit 1，1表示从第1位取一位，也就是第2位-->

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Select IFNULL((select distinct(Salary) as SecondHighestSalary from Employee order by Salary desc limit 1,1),null) AS SecondHighestSalary</span><br></pre></td></tr></table></figure>

<p>SQL写法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">Max</span>(Salary) <span class="keyword">as</span> SecondHighestSalary <span class="keyword">from</span> Employee <span class="keyword">WHERE</span> Salary&lt;(<span class="keyword">select</span> <span class="keyword">Max</span>(Salary) <span class="keyword">from</span> Employee)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣-SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Singleton</title>
    <url>/2019/10/11/Singleton/</url>
    <content><![CDATA[<p><strong>一、单例模式的定义</strong></p>
<p>　　确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一的实例，是一种对象创建型模式，有如下3个要点：</p>
<ul>
<li>只能有一个实例</li>
<li>必须是自行创建这个实例</li>
<li>必须自行向整个系统提供这个实例</li>
</ul>
<p><strong>二、单例模式的结构</strong></p>
<ul>
<li><p>一个类型为自身的静态私有成员变量 - 存储唯一实例</p>
</li>
<li><p>一个私有的构造函数</p>
</li>
<li><p>一个公有的静态成员方法 ，返回唯一实例，对象为自身</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Singleton</span><br><span class="line">    &#123;</span><br><span class="line">        //静态私有成员变量，存储唯一实例</span><br><span class="line">        private static Singleton _instance = null;   、</span><br><span class="line">        </span><br><span class="line">        //私有构造函数，保证唯一性</span><br><span class="line">        private Singleton()   </span><br><span class="line">        &#123; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //公有静态方法，返回一个唯一的实例</span><br><span class="line">        public static Singleton GetInstance()    </span><br><span class="line">        &#123;</span><br><span class="line">            if (_instance == null)</span><br><span class="line">            &#123;</span><br><span class="line">                _instance = new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">            return _instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>三、单例模式的两种书写方法</strong></p>
<p>1.类被加载时就将自己实例化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Singleton</span><br><span class="line">    &#123;</span><br><span class="line">        private static Singleton _instance = new Singleton();</span><br><span class="line">       </span><br><span class="line">        private Singleton()</span><br><span class="line">        &#123; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static Singleton GetInstance()</span><br><span class="line">        &#123;</span><br><span class="line">            return _instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>2.类在第一次被引用时将自己实例化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Singleton</span><br><span class="line">    &#123;</span><br><span class="line">        private static Singleton _instance = null;</span><br><span class="line">        private static readonly object syncRoot = new object();   </span><br><span class="line"></span><br><span class="line">        private Singleton()</span><br><span class="line">        &#123; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static Singleton GetInstance()</span><br><span class="line">        &#123;</span><br><span class="line">            if (_instance == null)</span><br><span class="line">            &#123;</span><br><span class="line">                lock (syncRoot)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (_instance == null)</span><br><span class="line">                    &#123;</span><br><span class="line">                        _instance = new Singleton();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return _instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>四、双重锁的运用分析</strong></p>
<p>​     在上述代码中出现“If - Lock - If”结构模式，即双重检查锁定的双重判断机制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//第一重判断，先判断实例是否存在，不存在再加锁处理</span><br><span class="line">if (_instance == null)   </span><br><span class="line">            &#123;</span><br><span class="line">             //加锁，在某一时刻只允许一个线程访问</span><br><span class="line">                lock (syncRoot)  </span><br><span class="line">                &#123;</span><br><span class="line">                //第二重判断: 第一个线程进入Lock中执行创建代码，第二个线程处于排队等待状态，当第二个线程进入Lock后并不知道实例已创建，将会继续创建新的实例</span><br><span class="line">                    if (_instance == null)   </span><br><span class="line">                    &#123;</span><br><span class="line">                        _instance = new SingletonClass();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p><strong>五、单例模式的优缺点</strong></p>
<ul>
<li><p>封装了唯一性，可严格控制客户怎么访问及何时访问</p>
</li>
<li><p>内存中只存在一个对象，可节约系统资源，提高系统性能</p>
</li>
<li><p>单例类的扩展不方便</p>
</li>
<li><p>单例类既提供了业务方法，又提供了创建对象的方法，将对象的创建和对象本身的功能耦合在一起</p>
</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>力扣-数据库2</title>
    <url>/2019/10/11/%E5%8A%9B%E6%89%A3-%E6%95%B0%E6%8D%AE%E5%BA%932/</url>
    <content><![CDATA[<p>题目：给定一个 <code>Weather</code> 表，编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 Id。</p>
<p><img src="/2019/10/11/力扣-数据库2/1570700754194.png" alt></p>
<p><strong>解题</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> w1.Id <span class="keyword">from</span> Weather w1 <span class="keyword">join</span> Weather w2 <span class="keyword">on</span> <span class="keyword">DATEDIFF</span>(w1.RecordDate, w2.RecordDate) = <span class="number">1</span> <span class="keyword">and</span> w1.Temperature&gt;w2.Temperature</span><br></pre></td></tr></table></figure>

<p>DATEDIFF的使用说明：</p>
<p>可以参考：<a href="http://www.360doc.com/content/15/0921/15/110467_500515921.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/15/0921/15/110467_500515921.shtml</a></p>
]]></content>
      <categories>
        <category>力扣-SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣-数据库1</title>
    <url>/2019/10/11/%E5%8A%9B%E6%89%A3-%E6%95%B0%E6%8D%AE%E5%BA%931/</url>
    <content><![CDATA[<p>1.编写一个 SQL 查询，来删除 Person表中所有重复的电子邮箱，重复的邮箱里只保留 Id 最小 的那个。</p>
<p>题目：</p>
<p>编写一个 SQL 查询，来删除 <code>Person</code>表中所有重复的电子邮箱，重复的邮箱里只保留 Id <em>最小</em> 的那个。</p>
<p><img src="/2019/10/11/力扣-数据库1/1570699229660.png" alt></p>
<p>​         自己的想法陷入了死胡同，发现在MySql中的Delete和Select不能同时运行！</p>
<p>后来看了大神的写法，顿时了解了！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">delete  p1 from  Person p1, Person p2 where (p1.email = p2.email) and (p1.id &gt; p2.id)</span><br></pre></td></tr></table></figure>

<p>借鉴别人的想法：<a href="https://blog.csdn.net/mrlin6688/article/details/100537858" target="_blank" rel="noopener">https://blog.csdn.net/mrlin6688/article/details/100537858</a></p>
]]></content>
      <categories>
        <category>力扣-SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/2019/10/10/test/</url>
    <content><![CDATA[<p>​       今天开始我的<strong>第一篇*</strong>Bolg*文章分享，以后<u>加油</u>！</p>
<h2 id="1-搭建博客的由来"><a href="#1-搭建博客的由来" class="headerlink" title="1.搭建博客的由来"></a>1.搭建博客的由来</h2><p>​        看到表弟发布一个Hexo博客，还用Goihub部署，想想省去了服务器的钱，果断自己搭建一个自己的学习心技术分享的博客！</p>
<h2 id="2-搭建过程"><a href="#2-搭建过程" class="headerlink" title="2.搭建过程"></a>2.搭建过程</h2><p>​      开始了自己的搭建过程，挺简单的！当中遇到几个问题，遇到问题就百度！都解决了！</p>
<p>参考学习：<a href="https://www.cnblogs.com/cherishzy/p/5694658.html" target="_blank" rel="noopener">https://www.cnblogs.com/cherishzy/p/5694658.html</a></p>
<h2 id="3-下次的学习心得分享"><a href="#3-下次的学习心得分享" class="headerlink" title="3.下次的学习心得分享"></a>3.下次的学习心得分享</h2><p>​     现在学习多线程、数据结构、ASP.NET CORE等！</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/10/10/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
